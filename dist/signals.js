var He=Object.defineProperty,ze=(e,t,r)=>t in e?He(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,de=(e,t,r)=>(ze(e,typeof t!="symbol"?t+"":t,r),r),Ye=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},pe=(e,t)=>{if(Object(t)!==t)throw TypeError('Cannot use the "in" operator on this value');return e.has(t)},X=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},ke=(e,t,r)=>(Ye(e,t,"access private method"),r);function De(e,t){return Object.is(e,t)}var v=null,G=!1,Z=1,ee=Symbol("SIGNAL");function k(e){let t=v;return v=e,t}function Je(){return v}function Qe(){return G}var ye={version:0,lastCleanEpoch:0,dirty:!1,producerNode:void 0,producerLastReadVersion:void 0,producerIndexOfThis:void 0,nextProducerIndex:0,liveConsumerNode:void 0,liveConsumerIndexOfThis:void 0,consumerAllowSignalWrites:!1,consumerIsAlwaysLive:!1,producerMustRecompute:()=>!1,producerRecomputeValue:()=>{},consumerMarkedDirty:()=>{},consumerOnSignalRead:()=>{}};function te(e){if(G)throw new Error(typeof ngDevMode<"u"&&ngDevMode?"Assertion error: signal read during notification phase":"");if(v===null)return;v.consumerOnSignalRead(e);let t=v.nextProducerIndex++;if(D(v),t<v.producerNode.length&&v.producerNode[t]!==e&&ve(v)){let r=v.producerNode[t];re(r,v.producerIndexOfThis[t])}v.producerNode[t]!==e&&(v.producerNode[t]=e,v.producerIndexOfThis[t]=ve(v)?qe(e,v,t):0),v.producerLastReadVersion[t]=e.version}function Xe(){Z++}function je(e){if(!(!e.dirty&&e.lastCleanEpoch===Z)){if(!e.producerMustRecompute(e)&&!nt(e)){e.dirty=!1,e.lastCleanEpoch=Z;return}e.producerRecomputeValue(e),e.dirty=!1,e.lastCleanEpoch=Z}}function Fe(e){if(e.liveConsumerNode===void 0)return;let t=G;G=!0;try{for(let r of e.liveConsumerNode)r.dirty||et(r)}finally{G=t}}function Ze(){return v?.consumerAllowSignalWrites!==!1}function et(e){var t;e.dirty=!0,Fe(e),(t=e.consumerMarkedDirty)==null||t.call(e.wrapper??e)}function tt(e){return e&&(e.nextProducerIndex=0),k(e)}function rt(e,t){if(k(t),!(!e||e.producerNode===void 0||e.producerIndexOfThis===void 0||e.producerLastReadVersion===void 0)){if(ve(e))for(let r=e.nextProducerIndex;r<e.producerNode.length;r++)re(e.producerNode[r],e.producerIndexOfThis[r]);for(;e.producerNode.length>e.nextProducerIndex;)e.producerNode.pop(),e.producerLastReadVersion.pop(),e.producerIndexOfThis.pop()}}function nt(e){D(e);for(let t=0;t<e.producerNode.length;t++){let r=e.producerNode[t],n=e.producerLastReadVersion[t];if(n!==r.version||(je(r),n!==r.version))return!0}return!1}function qe(e,t,r){var n;if(Te(e),D(e),e.liveConsumerNode.length===0){(n=e.watched)==null||n.call(e.wrapper);for(let a=0;a<e.producerNode.length;a++)e.producerIndexOfThis[a]=qe(e.producerNode[a],e,a)}return e.liveConsumerIndexOfThis.push(r),e.liveConsumerNode.push(t)-1}function re(e,t){var r;if(Te(e),D(e),typeof ngDevMode<"u"&&ngDevMode&&t>=e.liveConsumerNode.length)throw new Error(`Assertion error: active consumer index ${t} is out of bounds of ${e.liveConsumerNode.length} consumers)`);if(e.liveConsumerNode.length===1){(r=e.unwatched)==null||r.call(e.wrapper);for(let a=0;a<e.producerNode.length;a++)re(e.producerNode[a],e.producerIndexOfThis[a])}let n=e.liveConsumerNode.length-1;if(e.liveConsumerNode[t]=e.liveConsumerNode[n],e.liveConsumerIndexOfThis[t]=e.liveConsumerIndexOfThis[n],e.liveConsumerNode.length--,e.liveConsumerIndexOfThis.length--,t<e.liveConsumerNode.length){let a=e.liveConsumerIndexOfThis[t],h=e.liveConsumerNode[t];D(h),h.producerIndexOfThis[a]=t}}function ve(e){var t;return e.consumerIsAlwaysLive||(((t=e?.liveConsumerNode)==null?void 0:t.length)??0)>0}function D(e){e.producerNode??(e.producerNode=[]),e.producerIndexOfThis??(e.producerIndexOfThis=[]),e.producerLastReadVersion??(e.producerLastReadVersion=[])}function Te(e){e.liveConsumerNode??(e.liveConsumerNode=[]),e.liveConsumerIndexOfThis??(e.liveConsumerIndexOfThis=[])}function Le(e){if(je(e),te(e),e.value===we)throw e.error;return e.value}function st(e){let t=Object.create(ot);t.computation=e;let r=()=>Le(t);return r[ee]=t,r}var me=Symbol("UNSET"),ge=Symbol("COMPUTING"),we=Symbol("ERRORED"),ot={...ye,value:me,dirty:!0,error:null,equal:De,producerMustRecompute(e){return e.value===me||e.value===ge},producerRecomputeValue(e){if(e.value===ge)throw new Error("Detected cycle in computations.");let t=e.value;e.value=ge;let r=tt(e),n,a=!1;try{n=e.computation.call(e.wrapper),a=t!==me&&t!==we&&e.equal.call(e.wrapper,t,n)}catch(h){n=we,e.error=h}finally{rt(e,r)}if(a){e.value=t;return}e.value=n,e.version++}};function it(){throw new Error}var at=it;function ut(){at()}function lt(e){let t=Object.create(ft);t.value=e;let r=()=>(te(t),t.value);return r[ee]=t,r}function ct(){return te(this),this.value}function ht(e,t){Ze()||ut(),e.equal.call(e.wrapper,e.value,t)||(e.value=t,dt(e))}var ft={...ye,equal:De,value:void 0};function dt(e){e.version++,Xe(),Fe(e)}var T=Symbol("node"),u;(e=>{var t,r,n,a,h,f;class s{constructor(y,w={}){X(this,r),de(this,t);let g=lt(y)[ee];if(this[T]=g,g.wrapper=this,w){let V=w.equals;V&&(g.equal=V),g.watched=w[e.subtle.watched],g.unwatched=w[e.subtle.unwatched]}}get(){if(!(0,e.isState)(this))throw new TypeError("Wrong receiver type for Signal.State.prototype.get");return ct.call(this[T])}set(y){if(!(0,e.isState)(this))throw new TypeError("Wrong receiver type for Signal.State.prototype.set");if(Qe())throw new Error("Writes to signals not permitted during Watcher callback");let w=this[T];ht(w,y)}}t=T,r=new WeakSet,n=function(){},e.isState=d=>pe(r,d),e.State=s;class m{constructor(y,w){X(this,h),de(this,a);let g=st(y)[ee];if(g.consumerAllowSignalWrites=!0,this[T]=g,g.wrapper=this,w){let V=w.equals;V&&(g.equal=V),g.watched=w[e.subtle.watched],g.unwatched=w[e.subtle.unwatched]}}get(){if(!(0,e.isComputed)(this))throw new TypeError("Wrong receiver type for Signal.Computed.prototype.get");return Le(this[T])}}a=T,h=new WeakSet,f=function(){},e.isComputed=d=>pe(h,d),e.Computed=m,(d=>{var y,w,A,g,V;function q(o){let l,i=null;try{i=k(null),l=o()}finally{k(i)}return l}d.untrack=q;function B(o){var l;if(!(0,e.isComputed)(o)&&!(0,e.isWatcher)(o))throw new TypeError("Called introspectSources without a Computed or Watcher argument");return((l=o[T].producerNode)==null?void 0:l.map(i=>i.wrapper))??[]}d.introspectSources=B;function K(o){var l;if(!(0,e.isComputed)(o)&&!(0,e.isState)(o))throw new TypeError("Called introspectSinks without a Signal argument");return((l=o[T].liveConsumerNode)==null?void 0:l.map(i=>i.wrapper))??[]}d.introspectSinks=K;function R(o){if(!(0,e.isComputed)(o)&&!(0,e.isState)(o))throw new TypeError("Called hasSinks without a Signal argument");let l=o[T].liveConsumerNode;return l?l.length>0:!1}d.hasSinks=R;function N(o){if(!(0,e.isComputed)(o)&&!(0,e.isWatcher)(o))throw new TypeError("Called hasSources without a Computed or Watcher argument");let l=o[T].producerNode;return l?l.length>0:!1}d.hasSources=N;class ${constructor(l){X(this,w),X(this,g),de(this,y);let i=Object.create(ye);i.wrapper=this,i.consumerMarkedDirty=l,i.consumerIsAlwaysLive=!0,i.consumerAllowSignalWrites=!1,i.producerNode=[],this[T]=i}watch(...l){if(!(0,e.isWatcher)(this))throw new TypeError("Called unwatch without Watcher receiver");ke(this,g,V).call(this,l);let i=this[T];i.dirty=!1;let c=k(i);for(let p of l)te(p[T]);k(c)}unwatch(...l){if(!(0,e.isWatcher)(this))throw new TypeError("Called unwatch without Watcher receiver");ke(this,g,V).call(this,l);let i=this[T];D(i);for(let c=i.producerNode.length-1;c>=0;c--)if(l.includes(i.producerNode[c].wrapper)){re(i.producerNode[c],i.producerIndexOfThis[c]);let p=i.producerNode.length-1;if(i.producerNode[c]=i.producerNode[p],i.producerIndexOfThis[c]=i.producerIndexOfThis[p],i.producerNode.length--,i.producerIndexOfThis.length--,i.nextProducerIndex--,c<i.producerNode.length){let O=i.producerIndexOfThis[c],I=i.producerNode[c];Te(I),I.liveConsumerIndexOfThis[O]=c}}}getPending(){if(!(0,e.isWatcher)(this))throw new TypeError("Called getPending without Watcher receiver");return this[T].producerNode.filter(i=>i.dirty).map(i=>i.wrapper)}}y=T,w=new WeakSet,A=function(){},g=new WeakSet,V=function(o){for(let l of o)if(!(0,e.isComputed)(l)&&!(0,e.isState)(l))throw new TypeError("Called watch/unwatch without a Computed or State argument")},e.isWatcher=o=>pe(w,o),d.Watcher=$;function H(){var o;return(o=Je())==null?void 0:o.wrapper}d.currentComputed=H,d.watched=Symbol("watched"),d.unwatched=Symbol("unwatched")})(e.subtle||(e.subtle={}))})(u||(u={}));var x=(e=null)=>new u.State(e,{equals:()=>!1});var pt=new Set([Symbol.iterator,"concat","entries","every","filter","find","findIndex","flat","flatMap","forEach","includes","indexOf","join","keys","lastIndexOf","map","reduce","reduceRight","slice","some","values"]),mt=new Set(["fill","push","unshift"]);function Ue(e){if(typeof e=="symbol")return null;let t=Number(e);return isNaN(t)?null:t%1===0?t:null}var ne=class e{static from(t,r,n){return r?new e(Array.from(t,r,n)):new e(Array.from(t))}static of(...t){return new e(t)}constructor(t=[]){let r=t.slice(),n=this,a=new Map,h=!1;return new Proxy(r,{get(f,s){let m=Ue(s);if(m!==null)return n.#s(m),n.#e.get(),f[m];if(s==="length")return h?h=!1:n.#e.get(),f[s];if(mt.has(s)&&(h=!0),pt.has(s)){let d=a.get(s);return d===void 0&&(d=(...y)=>(n.#e.get(),f[s](...y)),a.set(s,d)),d}return f[s]},set(f,s,m){f[s]=m;let d=Ue(s);return d!==null?(n.#n(d),n.#e.set(null)):s==="length"&&n.#e.set(null),!0},getPrototypeOf(){return e.prototype}})}#e=x();#t=new Map;#s(t){let r=this.#t.get(t);r===void 0&&(r=x(),this.#t.set(t,r)),r.get()}#n(t){let r=this.#t.get(t);r&&r.set(null)}};Object.setPrototypeOf(ne.prototype,Array.prototype);var Se=class e{static fromEntries(t){return new e(Object.fromEntries(t))}#e=new Map;#t=x();constructor(t={}){let r=Object.getPrototypeOf(t),n=Object.getOwnPropertyDescriptors(t),a=Object.create(r);for(let f in n)Object.defineProperty(a,f,n[f]);let h=this;return new Proxy(a,{get(f,s,m){return h.#s(s),Reflect.get(f,s,m)},has(f,s){return h.#s(s),s in f},ownKeys(f){return h.#t.get(),Reflect.ownKeys(f)},set(f,s,m,d){let y=Reflect.set(f,s,m,d);return h.#n(s),h.#r(),y},deleteProperty(f,s){return s in f&&(delete f[s],h.#n(s),h.#r()),!0},getPrototypeOf(){return e.prototype}})}#s(t){let r=this.#e.get(t);r===void 0&&(r=x(),this.#e.set(t,r)),r.get()}#n(t){let r=this.#e.get(t);r&&r.set(null)}#r(){this.#t.set(null)}},gt=Se;var se=class{collection=x();storages=new Map;vals;readStorageFor(t){let{storages:r}=this,n=r.get(t);n===void 0&&(n=x(),r.set(t,n)),n.get()}dirtyStorageFor(t){let r=this.storages.get(t);r&&r.set(null)}constructor(t){this.vals=t?new Map(t):new Map}get(t){return this.readStorageFor(t),this.vals.get(t)}has(t){return this.readStorageFor(t),this.vals.has(t)}entries(){return this.collection.get(),this.vals.entries()}keys(){return this.collection.get(),this.vals.keys()}values(){return this.collection.get(),this.vals.values()}forEach(t){this.collection.get(),this.vals.forEach(t)}get size(){return this.collection.get(),this.vals.size}[Symbol.iterator](){return this.collection.get(),this.vals[Symbol.iterator]()}get[Symbol.toStringTag](){return this.vals[Symbol.toStringTag]}set(t,r){return this.dirtyStorageFor(t),this.collection.set(null),this.vals.set(t,r),this}delete(t){return this.dirtyStorageFor(t),this.collection.set(null),this.vals.delete(t)}clear(){this.storages.forEach(t=>t.set(null)),this.collection.set(null),this.vals.clear()}};Object.setPrototypeOf(se.prototype,Map.prototype);var oe=class{collection=x();storages=new Map;vals;storageFor(t){let r=this.storages,n=r.get(t);return n===void 0&&(n=x(),r.set(t,n)),n}dirtyStorageFor(t){let r=this.storages.get(t);r&&r.set(null)}constructor(t){this.vals=new Set(t)}has(t){return this.storageFor(t).get(),this.vals.has(t)}entries(){return this.collection.get(),this.vals.entries()}keys(){return this.collection.get(),this.vals.keys()}values(){return this.collection.get(),this.vals.values()}forEach(t){this.collection.get(),this.vals.forEach(t)}get size(){return this.collection.get(),this.vals.size}[Symbol.iterator](){return this.collection.get(),this.vals[Symbol.iterator]()}get[Symbol.toStringTag](){return this.vals[Symbol.toStringTag]}add(t){return this.dirtyStorageFor(t),this.collection.set(null),this.vals.add(t),this}delete(t){return this.dirtyStorageFor(t),this.collection.set(null),this.vals.delete(t)}clear(){this.storages.forEach(t=>t.set(null)),this.collection.set(null),this.vals.clear()}};Object.setPrototypeOf(oe.prototype,Set.prototype);function Ge(...e){if(e[1].kind==="accessor")return vt(...e);if(e[1].kind==="getter")return wt(...e);throw new Error("@signal can only be used on accessors or getters")}function vt(e,t){let{get:r}=e;if(t.kind!=="accessor")throw new Error("Expected to be used on an accessor property");return{get(){return r.call(this).get()},set(n){r.call(this).set(n)},init(n){return new u.State(n)}}}function wt(e,t){if(t.kind!=="getter")throw new Error("Can only use @cached on getters.");let n=new WeakMap;return function(){let a=n.get(e);return a||(a=new u.Computed(()=>e.call(this)),n.set(e,a)),a.get()}}var Be,Ke;function yt(e,t,r,n,a,h){var f,s,m,d,y,w,A,g=Symbol.metadata||Symbol.for("Symbol.metadata"),V=Object.defineProperty,q=Object.create,B=[q(null),q(null)],K=t.length;function R(o,l,i){return function(c,p){l&&(p=c,c=e);for(var O=0;O<o.length;O++)p=o[O].apply(c,i?[p]:[]);return i?p:c}}function N(o,l,i,c){if(typeof o!="function"&&(c||o!==void 0))throw new TypeError(l+" must "+(i||"be")+" a function"+(c?"":" or undefined"));return o}function $(o,l,i,c,p,O,I,E,M,_,Ne){function ue(C){if(!Ne(C))throw new TypeError("Attempted to access private element on non-instance")}var le=[].concat(l[0]),Ie=l[3],ce=!I,L=p===1,Ae=p===3,Me=p===4,z=p===2;function Y(C,W,Re){return function(Q,We){return W&&(We=Q,Q=o),Re&&Re(Q),S[C].call(Q,We)}}if(!ce){var S={},he=[],P=Ae?"get":Me||L?"set":"value";if(M?(_||L?S={get:$e(function(){return Ie(this)},c,"get"),set:function(C){l[4](this,C)}}:S[P]=Ie,_||$e(S[P],c,z?"":P)):_||(S=Object.getOwnPropertyDescriptor(o,c)),!_&&!M){if((s=B[+E][c])&&(s^p)!=7)throw Error("Decorating two elements with the same name ("+S[P].name+") is not supported yet");B[+E][c]=p<3?1:p}}for(var b=o,J=le.length-1;J>=0;J-=i?2:1){var _e=N(le[J],"A decorator","be",!0),Pe=i?le[J-1]:void 0,fe={},U={kind:["field","accessor","method","getter","setter","class"][p],name:c,metadata:f,addInitializer:function(C,W){if(C.v)throw Error("attempted to call addInitializer after decoration was finished");N(W,"An initializer","be",!0),O.push(W)}.bind(null,fe)};if(ce)s=_e.call(Pe,b,U),fe.v=1,N(s,"class decorators","return")&&(b=s);else if(U.static=E,U.private=M,s=U.access={has:M?Ne.bind():function(C){return c in C}},Me||(s.get=M?z?function(C){return ue(C),S.value}:Y("get",0,ue):function(C){return C[c]}),z||Ae||(s.set=M?Y("set",0,ue):function(C,W){C[c]=W}),b=_e.call(Pe,L?{get:S.get,set:S.set}:S[P],U),fe.v=1,L){if(typeof b=="object"&&b)(s=N(b.get,"accessor.get"))&&(S.get=s),(s=N(b.set,"accessor.set"))&&(S.set=s),(s=N(b.init,"accessor.init"))&&he.unshift(s);else if(b!==void 0)throw new TypeError("accessor decorators must return an object with get, set, or init properties or undefined")}else N(b,(_?"field":"method")+" decorators","return")&&(_?he.unshift(b):S[P]=b)}return p<2&&I.push(R(he,E,1),R(O,E,0)),_||ce||(M?L?I.splice(-1,0,Y("get",E),Y("set",E)):I.push(z?S[P]:N.call.bind(S[P])):V(o,c,S)),b}function H(o){return V(o,g,{configurable:!0,enumerable:!0,value:f})}return h!==void 0&&(f=h[g]),f=q(f??null),y=[],w=function(o){o&&y.push(R(o))},A=function(o,l){for(var i=0;i<r.length;i++){var c=r[i],p=c[1],O=7&p;if((8&p)==o&&!O==l){var I=c[2],E=!!c[3],M=16&p;$(o?e:e.prototype,c,M,E?"#"+I:Tt(I),O,O<2?[]:o?d=d||[]:m=m||[],y,!!o,E,l,o&&E?function(_){return Ct(_)===e}:a)}}},A(8,0),A(0,0),A(8,1),A(0,1),w(m),w(d),s=y,K||H(e),{e:s,get c(){var o=[];return K&&[H(e=$(e,[t],n,e.name,5,o)),R(o,1)]}}}function Tt(e){var t=St(e,"string");return typeof t=="symbol"?t:t+""}function St(e,t){if(typeof e!="object"||!e)return e;var r=e[Symbol.toPrimitive];if(r!==void 0){var n=r.call(e,t||"default");if(typeof n!="object")return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return(t==="string"?String:Number)(e)}function $e(e,t,r){typeof t=="symbol"&&(t=(t=t.description)?"["+t+"]":"");try{Object.defineProperty(e,"name",{configurable:!0,value:r?r+" "+t:t})}catch{}return e}function Ct(e){if(Object(e)!==e)throw TypeError("right-hand side of 'in' should be an object, got "+(e!==null?typeof e:"null"));return e}var Ce=class{static{[Be,Ke]=yt(this,[],[[Ge,1,"value"]]).e}constructor(){Ke(this)}prevRemote;peek;#e=Be(this);get value(){return this.#e}set value(t){this.#e=t}};function j(e,t,r){let n=t.get(e);return n===void 0&&(n=new Ce,t.set(e,n),n.value=n.peek=typeof r=="function"?r.call(e):r),n}function bt(e,t){let r=e,n=t.split(".");for(let a of n){if(!r)return r;if(!(a in r))throw new Error(`sub-path ${a} (from ${t}) does not exist on ${JSON.stringify(r)}.`);r=r[a]}return r}function Vt(...e){if(typeof e[0]=="function")return Ot(e[0]);let[t,r]=e;return xt(t,r)}function Ot(e){let t=new WeakMap;return{get(){let r=j(this,t),{prevRemote:n}=r,a=e();return n!==a&&(r.value=r.prevRemote=a),r.value},set(r){if(!t.has(this)){let n=j(this,t);n.prevRemote=e(),n.value=r;return}j(this,t).value=r}}}function xt(e,t){if(typeof e!="string")throw new Error(`@localCopy() must be given a memo path as its first argument, received \`${String(e)}\``);let r=new WeakMap;return function(a,h){let f=s=>bt(s,e);return{get(){let s=j(this,r,t),{prevRemote:m}=s,d=f(this);return m!==d&&(s.value=s.prevRemote=d),s.value},set(s){if(!r.has(this)){let m=j(this,r,t);m.prevRemote=f(this),m.value=s;return}j(this,r,t).value=s}}}}var be=class{#e=!1;#t=new u.State("initial");get status(){let t=this.#t.get();return this.#e?"pending":t}#s;get value(){return this.run(),this.#s.get()}#n=new u.State(void 0);get error(){return this.run(),this.#n.get()}#r=new u.State(void 0);get complete(){return this.run(),this.#r.get().promise}#o;#i;#a=0;#u;constructor(t,r){this.#s=new u.State(r?.initialValue),this.#o=new u.Computed(()=>{let n=++this.#a;u.subtle.untrack(()=>this.#t.get())!=="pending"&&this.#r.set(Promise.withResolvers()),this.#e=!1,this.#t.set("pending"),this.#u?.abort(),this.#u=new AbortController,t(this.#u.signal).then(h=>{n===this.#a&&(this.#t.set("complete"),this.#s.set(h),this.#n.set(void 0),this.#r.get().resolve(h))},h=>{n===this.#a&&(this.#t.set("error"),this.#n.set(h),this.#s.set(void 0),this.#r.get().reject(h))})}),this.#i=new u.subtle.Watcher(async()=>{this.#e=!0,this.#i.watch()}),this.#i.watch(this.#o)}get(){let t=this.status;if(t==="error"||t==="pending"&&this.error!==void 0)throw this.error;return this.value}run(){this.#o.get()}};var Ve=!1,ie=new u.subtle.Watcher(()=>{Ve||(Ve=!0,queueMicrotask(()=>{Ve=!1,Et()}))});function Et(){for(let e of ie.getPending())e.get();ie.watch()}function Nt(e){let t=new u.Computed(()=>e());return ie.watch(t),t.get(),()=>{ie.unwatch(t)}}function It(e,t){return new F(e,t)}var F=class{#e;#t;constructor(t,r){this.#e=t,this.#s=new u.State(r?.initialValue),this.staleTime=r?.staleTime,this.#t=new u.Computed(()=>(this.refresh(),this))}async refresh(){this.#r.set("fetching");try{let t=await this.#e();this.setValue(t)}catch(t){this.#r.set("rejected"),this.#n.set(t)}}#s;get value(){return this.#r.get()==="stale"&&this.refresh(),this.#t.get(),this.#s.get()}setValue(t){this.#r.set("resolved"),this.#s.set(t),this.#n.set(null),this.#i()}#n=new u.State(null);get error(){return this.#r.get()==="rejected"?this.#n.get():null}#r=new u.State("initial");get status(){return this.#t.get(),this.#r.get()}get isPending(){let t=this.status;return t==="fetching"||t==="initial"}get isResolved(){return this.status==="resolved"}get isRejected(){return this.status==="rejected"}#o;#i(){clearTimeout(this.#o),this.staleTime!==void 0&&(this.#o=setTimeout(()=>this.#r.set("stale"),this.staleTime))}};var Oe=new Map;function At(e,t,r){if(Oe.has(e))return Oe.get(e);{let n=new F(t,r);return Oe.set(e,n),n}}var ae=class{#e;#t=new u.State(null);#s=new u.State(!1);#n=new u.State(!1);constructor(t={}){this.#e=t.validate,this.initialValue=t.initialValue,this.fields={};for(let r in t.fields)this.fields[r]=new Ee(this,r,{...t.fields[r],initialValue:t.initialValue?.[r]})}get fieldArray(){return Object.values(this.fields)}async#r(){try{let t=await this.#e?.(this.value);return this.#t.set(t),!!t}catch(t){return this.#t.set(t),!!t}}async validate(){this.#n.set(!1),this.#s.set(!0);let t=await Promise.all([this.#r(),...this.fieldArray.map(r=>r.validate())]);return this.#n.set(!0),this.#s.set(!1),t.every(Boolean)}get error(){return this.#t.get()}get isValidated(){return this.#n.get()}get isValidating(){return this.#s.get()}get errors(){return[this.error].concat(...this.fieldArray.map(t=>t.errors)).filter(Boolean)}#o=new u.Computed(()=>this.value===this.initialValue);get isPristine(){return this.#o.get()}get isDirty(){return!this.isPristine}#i=new u.Computed(()=>this.isValidated&&!!this.error||this.fieldArray.some(t=>t.isInvalid));get isInvalid(){return this.#i.get()}get isValid(){return this.isValidated&&!this.isInvalid}get value(){throw new Error("Getter 'value' must be implemented in derived class.")}setValue(t){this.#n.set(!1)}},xe=class extends ae{#e;constructor(t){super(t),this.#e=new u.State(t.initialValue??{})}get value(){return this.#e.get()}setValue(t){super.setValue(t),this.#e.set(t)}#t=new u.State(0);#s=new u.Computed(()=>this.#t.get()>0);#n=new u.State(!1);#r=new u.State(null);async handleSubmit(t,r){try{await this.validate(),this.#n.set(!0),this.#r.set(null),this.isValid?this.#r.set(await t?.(this.value,this)):(this.focusError(),this.#r.set(await r?.(this.value,this)))}catch(n){this.#r.set(n)}finally{this.#n.set(!1),this.#t.set(this.#t.get()+1)}}get submitCount(){return this.#t.get()}get isSubmitted(){return this.#s.get()}get isSubmitting(){return this.#n.get()}focusError(){for(let t of this.fieldArray)if(t.focusError())return!0;return!1}},Ee=class extends ae{constructor(t,r,n){super(n),this.control=t,this.name=r,this.ref={}}#e=new u.Computed(()=>this.control.value?.[this.name]);get value(){return this.#e.get()}setValue(t){super.setValue(t);let r=this.control.value;this.control.setValue({...r,[this.name]:t})}focusError(){if(this.ref.value&&this.isInvalid)return this.ref.value.focus(),!0;for(let t of this.fieldArray)if(t.focusError())return!0;return!1}};function Mt(e,t){let r=new u.State(e(),t),n=new u.Computed(()=>{r.set(e())}),a=!1,h=new u.subtle.Watcher(()=>{a||(a=!0,queueMicrotask(()=>{n.get(),a=!1})),h.watch()});return h.watch(n),n.get(),r}function ur(e,t){return new u.State(e,t)}function lr(e,t){return new u.Computed(e,t)}export{be as AsyncComputed,F as AsyncMemo,xe as Form,u as Signal,ne as SignalArray,se as SignalMap,gt as SignalObject,oe as SignalSet,It as asyncMemo,Nt as effect,Vt as localCopy,lr as memo,At as query,ur as signal,Mt as writableMemo};
/*! Bundled license information:

signal-polyfill/dist/index.js:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)
  (**
   * @license
   * Copyright 2024 Bloomberg Finance L.P.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
*/
