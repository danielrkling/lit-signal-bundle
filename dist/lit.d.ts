// Generated by dts-bundle-generator v9.5.1

/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * Whether the current browser supports `adoptedStyleSheets`.
 */
export declare const supportsAdoptingStyleSheets: boolean;
/**
 * A CSSResult or native CSSStyleSheet.
 *
 * In browsers that support constructible CSS style sheets, CSSStyleSheet
 * object can be used for styling along side CSSResult from the `css`
 * template tag.
 */
export type CSSResultOrNative = CSSResult | CSSStyleSheet;
export type CSSResultArray = Array<CSSResultOrNative | CSSResultArray>;
/**
 * A single CSSResult, CSSStyleSheet, or an array or nested arrays of those.
 */
export type CSSResultGroup = CSSResultOrNative | CSSResultArray;
/**
 * A container for a string of CSS text, that may be used to create a CSSStyleSheet.
 *
 * CSSResult is the return value of `css`-tagged template literals and
 * `unsafeCSS()`. In order to ensure that CSSResults are only created via the
 * `css` tag and `unsafeCSS()`, CSSResult cannot be constructed directly.
 */
export declare class CSSResult {
	["_$cssResult$"]: boolean;
	readonly cssText: string;
	private _styleSheet?;
	private _strings;
	private constructor();
	get styleSheet(): CSSStyleSheet | undefined;
	toString(): string;
}
/**
 * Wrap a value for interpolation in a {@linkcode css} tagged template literal.
 *
 * This is unsafe because untrusted CSS text can be used to phone home
 * or exfiltrate data to an attacker controlled site. Take care to only use
 * this with trusted input.
 */
export declare const unsafeCSS: (value: unknown) => CSSResult;
/**
 * A template literal tag which can be used with LitElement's
 * {@linkcode LitElement.styles} property to set element styles.
 *
 * For security reasons, only literal string values and number may be used in
 * embedded expressions. To incorporate non-literal values {@linkcode unsafeCSS}
 * may be used inside an expression.
 */
export declare const css: (strings: TemplateStringsArray, ...values: (CSSResultGroup | number)[]) => CSSResult;
/**
 * Applies the given styles to a `shadowRoot`. When Shadow DOM is
 * available but `adoptedStyleSheets` is not, styles are appended to the
 * `shadowRoot` to [mimic spec behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).
 * Note, when shimming is used, any styles that are subsequently placed into
 * the shadowRoot should be placed *before* any shimmed adopted styles. This
 * will match spec behavior that gives adopted sheets precedence over styles in
 * shadowRoot.
 */
export declare const adoptStyles: (renderRoot: ShadowRoot, styles: Array<CSSResultOrNative>) => void;
export declare const getCompatibleStyle: (s: CSSResultOrNative) => CSSResultOrNative;
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * An object that can host Reactive Controllers and call their lifecycle
 * callbacks.
 */
export interface ReactiveControllerHost {
	/**
	 * Adds a controller to the host, which sets up the controller's lifecycle
	 * methods to be called with the host's lifecycle.
	 */
	addController(controller: ReactiveController): void;
	/**
	 * Removes a controller from the host.
	 */
	removeController(controller: ReactiveController): void;
	/**
	 * Requests a host update which is processed asynchronously. The update can
	 * be waited on via the `updateComplete` property.
	 */
	requestUpdate(): void;
	/**
	 * Returns a Promise that resolves when the host has completed updating.
	 * The Promise value is a boolean that is `true` if the element completed the
	 * update without triggering another update. The Promise result is `false` if
	 * a property was set inside `updated()`. If the Promise is rejected, an
	 * exception was thrown during the update.
	 *
	 * @return A promise of a boolean that indicates if the update resolved
	 *     without triggering another update.
	 */
	readonly updateComplete: Promise<boolean>;
}
/**
 * A Reactive Controller is an object that enables sub-component code
 * organization and reuse by aggregating the state, behavior, and lifecycle
 * hooks related to a single feature.
 *
 * Controllers are added to a host component, or other object that implements
 * the `ReactiveControllerHost` interface, via the `addController()` method.
 * They can hook their host components's lifecycle by implementing one or more
 * of the lifecycle callbacks, or initiate an update of the host component by
 * calling `requestUpdate()` on the host.
 */
export interface ReactiveController {
	/**
	 * Called when the host is connected to the component tree. For custom
	 * element hosts, this corresponds to the `connectedCallback()` lifecycle,
	 * which is only called when the component is connected to the document.
	 */
	hostConnected?(): void;
	/**
	 * Called when the host is disconnected from the component tree. For custom
	 * element hosts, this corresponds to the `disconnectedCallback()` lifecycle,
	 * which is called the host or an ancestor component is disconnected from the
	 * document.
	 */
	hostDisconnected?(): void;
	/**
	 * Called during the client-side host update, just before the host calls
	 * its own update.
	 *
	 * Code in `update()` can depend on the DOM as it is not called in
	 * server-side rendering.
	 */
	hostUpdate?(): void;
	/**
	 * Called after a host update, just before the host calls firstUpdated and
	 * updated. It is not called in server-side rendering.
	 *
	 */
	hostUpdated?(): void;
}
/**
 * Contains types that are part of the unstable debug API.
 *
 * Everything in this API is not stable and may change or be removed in the future,
 * even on patch releases.
 */
export declare namespace ReactiveUnstable {
	/**
	 * When Lit is running in dev mode and `window.emitLitDebugLogEvents` is true,
	 * we will emit 'lit-debug' events to window, with live details about the update and render
	 * lifecycle. These can be useful for writing debug tooling and visualizations.
	 *
	 * Please be aware that running with window.emitLitDebugLogEvents has performance overhead,
	 * making certain operations that are normally very cheap (like a no-op render) much slower,
	 * because we must copy data and dispatch events.
	 */
	namespace DebugLog {
		type Entry = Update;
		interface Update {
			kind: "update";
		}
	}
}
/**
 * Converts property values to and from attribute values.
 */
export interface ComplexAttributeConverter<Type = unknown, TypeHint = unknown> {
	/**
	 * Called to convert an attribute value to a property
	 * value.
	 */
	fromAttribute?(value: string | null, type?: TypeHint): Type;
	/**
	 * Called to convert a property value to an attribute
	 * value.
	 *
	 * It returns unknown instead of string, to be compatible with
	 * https://github.com/WICG/trusted-types (and similar efforts).
	 */
	toAttribute?(value: Type, type?: TypeHint): unknown;
}
export type AttributeConverter<Type = unknown, TypeHint = unknown> = ComplexAttributeConverter<Type> | ((value: string | null, type?: TypeHint) => Type);
/**
 * Defines options for a property accessor.
 */
export interface PropertyDeclaration<Type = unknown, TypeHint = unknown> {
	/**
	 * When set to `true`, indicates the property is internal private state. The
	 * property should not be set by users. When using TypeScript, this property
	 * should be marked as `private` or `protected`, and it is also a common
	 * practice to use a leading `_` in the name. The property is not added to
	 * `observedAttributes`.
	 */
	readonly state?: boolean;
	/**
	 * Indicates how and whether the property becomes an observed attribute.
	 * If the value is `false`, the property is not added to `observedAttributes`.
	 * If true or absent, the lowercased property name is observed (e.g. `fooBar`
	 * becomes `foobar`). If a string, the string value is observed (e.g
	 * `attribute: 'foo-bar'`).
	 */
	readonly attribute?: boolean | string;
	/**
	 * Indicates the type of the property. This is used only as a hint for the
	 * `converter` to determine how to convert the attribute
	 * to/from a property.
	 */
	readonly type?: TypeHint;
	/**
	 * Indicates how to convert the attribute to/from a property. If this value
	 * is a function, it is used to convert the attribute value a the property
	 * value. If it's an object, it can have keys for `fromAttribute` and
	 * `toAttribute`. If no `toAttribute` function is provided and
	 * `reflect` is set to `true`, the property value is set directly to the
	 * attribute. A default `converter` is used if none is provided; it supports
	 * `Boolean`, `String`, `Number`, `Object`, and `Array`. Note,
	 * when a property changes and the converter is used to update the attribute,
	 * the property is never updated again as a result of the attribute changing,
	 * and vice versa.
	 */
	readonly converter?: AttributeConverter<Type, TypeHint>;
	/**
	 * Indicates if the property should reflect to an attribute.
	 * If `true`, when the property is set, the attribute is set using the
	 * attribute name determined according to the rules for the `attribute`
	 * property option and the value of the property converted using the rules
	 * from the `converter` property option.
	 */
	readonly reflect?: boolean;
	/**
	 * A function that indicates if a property should be considered changed when
	 * it is set. The function should take the `newValue` and `oldValue` and
	 * return `true` if an update should be requested.
	 */
	hasChanged?(value: Type, oldValue: Type): boolean;
	/**
	 * Indicates whether an accessor will be created for this property. By
	 * default, an accessor will be generated for this property that requests an
	 * update when set. If this flag is `true`, no accessor will be created, and
	 * it will be the user's responsibility to call
	 * `this.requestUpdate(propertyName, oldValue)` to request an update when
	 * the property changes.
	 */
	readonly noAccessor?: boolean;
}
/**
 * Map of properties to PropertyDeclaration options. For each property an
 * accessor is made, and the property is processed according to the
 * PropertyDeclaration options.
 */
export interface PropertyDeclarations {
	readonly [key: string]: PropertyDeclaration;
}
export type PropertyDeclarationMap = Map<PropertyKey, PropertyDeclaration>;
/**
 * A Map of property keys to values.
 *
 * Takes an optional type parameter T, which when specified as a non-any,
 * non-unknown type, will make the Map more strongly-typed, associating the map
 * keys with their corresponding value type on T.
 *
 * Use `PropertyValues<this>` when overriding ReactiveElement.update() and
 * other lifecycle methods in order to get stronger type-checking on keys
 * and values.
 */
export type PropertyValues<T = any> = T extends object ? PropertyValueMap<T> : Map<PropertyKey, unknown>;
/**
 * Do not use, instead prefer {@linkcode PropertyValues}.
 */
export interface PropertyValueMap<T> extends Map<PropertyKey, unknown> {
	get<K extends keyof T>(k: K): T[K] | undefined;
	set<K extends keyof T>(key: K, value: T[K]): this;
	has<K extends keyof T>(k: K): boolean;
	delete<K extends keyof T>(k: K): boolean;
}
export declare const defaultConverter: ComplexAttributeConverter;
export interface HasChanged {
	(value: unknown, old: unknown): boolean;
}
/**
 * Change function that returns true if `value` is different from `oldValue`.
 * This method is used as the default for a property's `hasChanged` function.
 */
export declare const notEqual: HasChanged;
/**
 * A string representing one of the supported dev mode warning categories.
 */
export type WarningKind = "change-in-update" | "migration" | "async-perform-update";
export type Initializer = (element: ReactiveElement) => void;
/**
 * Base element class which manages element properties and attributes. When
 * properties change, the `update` method is asynchronously called. This method
 * should be supplied by subclasses to render updates as desired.
 * @noInheritDoc
 */
export declare abstract class ReactiveElement extends HTMLElement implements ReactiveControllerHost {
	/**
	 * Read or set all the enabled warning categories for this class.
	 *
	 * This property is only used in development builds.
	 *
	 * @nocollapse
	 * @category dev-mode
	 */
	static enabledWarnings?: WarningKind[];
	/**
	 * Enable the given warning category for this class.
	 *
	 * This method only exists in development builds, so it should be accessed
	 * with a guard like:
	 *
	 * ```ts
	 * // Enable for all ReactiveElement subclasses
	 * ReactiveElement.enableWarning?.('migration');
	 *
	 * // Enable for only MyElement and subclasses
	 * MyElement.enableWarning?.('migration');
	 * ```
	 *
	 * @nocollapse
	 * @category dev-mode
	 */
	static enableWarning?: (warningKind: WarningKind) => void;
	/**
	 * Disable the given warning category for this class.
	 *
	 * This method only exists in development builds, so it should be accessed
	 * with a guard like:
	 *
	 * ```ts
	 * // Disable for all ReactiveElement subclasses
	 * ReactiveElement.disableWarning?.('migration');
	 *
	 * // Disable for only MyElement and subclasses
	 * MyElement.disableWarning?.('migration');
	 * ```
	 *
	 * @nocollapse
	 * @category dev-mode
	 */
	static disableWarning?: (warningKind: WarningKind) => void;
	/**
	 * Adds an initializer function to the class that is called during instance
	 * construction.
	 *
	 * This is useful for code that runs against a `ReactiveElement`
	 * subclass, such as a decorator, that needs to do work for each
	 * instance, such as setting up a `ReactiveController`.
	 *
	 * ```ts
	 * const myDecorator = (target: typeof ReactiveElement, key: string) => {
	 *   target.addInitializer((instance: ReactiveElement) => {
	 *     // This is run during construction of the element
	 *     new MyController(instance);
	 *   });
	 * }
	 * ```
	 *
	 * Decorating a field will then cause each instance to run an initializer
	 * that adds a controller:
	 *
	 * ```ts
	 * class MyElement extends LitElement {
	 *   @myDecorator foo;
	 * }
	 * ```
	 *
	 * Initializers are stored per-constructor. Adding an initializer to a
	 * subclass does not add it to a superclass. Since initializers are run in
	 * constructors, initializers will run in order of the class hierarchy,
	 * starting with superclasses and progressing to the instance's class.
	 *
	 * @nocollapse
	 */
	static addInitializer(initializer: Initializer): void;
	static _initializers?: Initializer[];
	/**
	 * Maps attribute names to properties; for example `foobar` attribute to
	 * `fooBar` property. Created lazily on user subclasses when finalizing the
	 * class.
	 * @nocollapse
	 */
	private static __attributeToPropertyMap;
	/**
	 * Marks class as having been finalized, which includes creating properties
	 * from `static properties`, but does *not* include all properties created
	 * from decorators.
	 * @nocollapse
	 */
	protected static finalized: true | undefined;
	/**
	 * Memoized list of all element properties, including any superclass
	 * properties. Created lazily on user subclasses when finalizing the class.
	 *
	 * @nocollapse
	 * @category properties
	 */
	static elementProperties: PropertyDeclarationMap;
	/**
	 * User-supplied object that maps property names to `PropertyDeclaration`
	 * objects containing options for configuring reactive properties. When
	 * a reactive property is set the element will update and render.
	 *
	 * By default properties are public fields, and as such, they should be
	 * considered as primarily settable by element users, either via attribute or
	 * the property itself.
	 *
	 * Generally, properties that are changed by the element should be private or
	 * protected fields and should use the `state: true` option. Properties
	 * marked as `state` do not reflect from the corresponding attribute
	 *
	 * However, sometimes element code does need to set a public property. This
	 * should typically only be done in response to user interaction, and an event
	 * should be fired informing the user; for example, a checkbox sets its
	 * `checked` property when clicked and fires a `changed` event. Mutating
	 * public properties should typically not be done for non-primitive (object or
	 * array) properties. In other cases when an element needs to manage state, a
	 * private property set with the `state: true` option should be used. When
	 * needed, state properties can be initialized via public properties to
	 * facilitate complex interactions.
	 * @nocollapse
	 * @category properties
	 */
	static properties: PropertyDeclarations;
	/**
	 * Memoized list of all element styles.
	 * Created lazily on user subclasses when finalizing the class.
	 * @nocollapse
	 * @category styles
	 */
	static elementStyles: Array<CSSResultOrNative>;
	/**
	 * Array of styles to apply to the element. The styles should be defined
	 * using the {@linkcode css} tag function, via constructible stylesheets, or
	 * imported from native CSS module scripts.
	 *
	 * Note on Content Security Policy:
	 *
	 * Element styles are implemented with `<style>` tags when the browser doesn't
	 * support adopted StyleSheets. To use such `<style>` tags with the style-src
	 * CSP directive, the style-src value must either include 'unsafe-inline' or
	 * `nonce-<base64-value>` with `<base64-value>` replaced be a server-generated
	 * nonce.
	 *
	 * To provide a nonce to use on generated `<style>` elements, set
	 * `window.litNonce` to a server-generated nonce in your page's HTML, before
	 * loading application code:
	 *
	 * ```html
	 * <script>
	 *   // Generated and unique per request:
	 *   window.litNonce = 'a1b2c3d4';
	 * </script>
	 * ```
	 * @nocollapse
	 * @category styles
	 */
	static styles?: CSSResultGroup;
	/**
	 * Returns a list of attributes corresponding to the registered properties.
	 * @nocollapse
	 * @category attributes
	 */
	static get observedAttributes(): string[];
	private __instanceProperties?;
	/**
	 * Creates a property accessor on the element prototype if one does not exist
	 * and stores a {@linkcode PropertyDeclaration} for the property with the
	 * given options. The property setter calls the property's `hasChanged`
	 * property option or uses a strict identity check to determine whether or not
	 * to request an update.
	 *
	 * This method may be overridden to customize properties; however,
	 * when doing so, it's important to call `super.createProperty` to ensure
	 * the property is setup correctly. This method calls
	 * `getPropertyDescriptor` internally to get a descriptor to install.
	 * To customize what properties do when they are get or set, override
	 * `getPropertyDescriptor`. To customize the options for a property,
	 * implement `createProperty` like this:
	 *
	 * ```ts
	 * static createProperty(name, options) {
	 *   options = Object.assign(options, {myOption: true});
	 *   super.createProperty(name, options);
	 * }
	 * ```
	 *
	 * @nocollapse
	 * @category properties
	 */
	static createProperty(name: PropertyKey, options?: PropertyDeclaration): void;
	/**
	 * Returns a property descriptor to be defined on the given named property.
	 * If no descriptor is returned, the property will not become an accessor.
	 * For example,
	 *
	 * ```ts
	 * class MyElement extends LitElement {
	 *   static getPropertyDescriptor(name, key, options) {
	 *     const defaultDescriptor =
	 *         super.getPropertyDescriptor(name, key, options);
	 *     const setter = defaultDescriptor.set;
	 *     return {
	 *       get: defaultDescriptor.get,
	 *       set(value) {
	 *         setter.call(this, value);
	 *         // custom action.
	 *       },
	 *       configurable: true,
	 *       enumerable: true
	 *     }
	 *   }
	 * }
	 * ```
	 *
	 * @nocollapse
	 * @category properties
	 */
	protected static getPropertyDescriptor(name: PropertyKey, key: string | symbol, options: PropertyDeclaration): PropertyDescriptor | undefined;
	/**
	 * Returns the property options associated with the given property.
	 * These options are defined with a `PropertyDeclaration` via the `properties`
	 * object or the `@property` decorator and are registered in
	 * `createProperty(...)`.
	 *
	 * Note, this method should be considered "final" and not overridden. To
	 * customize the options for a given property, override
	 * {@linkcode createProperty}.
	 *
	 * @nocollapse
	 * @final
	 * @category properties
	 */
	static getPropertyOptions(name: PropertyKey): PropertyDeclaration<unknown, unknown>;
	static [Symbol.metadata]: object & Record<PropertyKey, unknown>;
	/**
	 * Initializes static own properties of the class used in bookkeeping
	 * for element properties, initializers, etc.
	 *
	 * Can be called multiple times by code that needs to ensure these
	 * properties exist before using them.
	 *
	 * This method ensures the superclass is finalized so that inherited
	 * property metadata can be copied down.
	 * @nocollapse
	 */
	private static __prepare;
	/**
	 * Finishes setting up the class so that it's ready to be registered
	 * as a custom element and instantiated.
	 *
	 * This method is called by the ReactiveElement.observedAttributes getter.
	 * If you override the observedAttributes getter, you must either call
	 * super.observedAttributes to trigger finalization, or call finalize()
	 * yourself.
	 *
	 * @nocollapse
	 */
	protected static finalize(): void;
	/**
	 * Options used when calling `attachShadow`. Set this property to customize
	 * the options for the shadowRoot; for example, to create a closed
	 * shadowRoot: `{mode: 'closed'}`.
	 *
	 * Note, these options are used in `createRenderRoot`. If this method
	 * is customized, options should be respected if possible.
	 * @nocollapse
	 * @category rendering
	 */
	static shadowRootOptions: ShadowRootInit;
	/**
	 * Takes the styles the user supplied via the `static styles` property and
	 * returns the array of styles to apply to the element.
	 * Override this method to integrate into a style management system.
	 *
	 * Styles are deduplicated preserving the _last_ instance in the list. This
	 * is a performance optimization to avoid duplicated styles that can occur
	 * especially when composing via subclassing. The last item is kept to try
	 * to preserve the cascade order with the assumption that it's most important
	 * that last added styles override previous styles.
	 *
	 * @nocollapse
	 * @category styles
	 */
	protected static finalizeStyles(styles?: CSSResultGroup): Array<CSSResultOrNative>;
	/**
	 * Node or ShadowRoot into which element DOM should be rendered. Defaults
	 * to an open shadowRoot.
	 * @category rendering
	 */
	readonly renderRoot: HTMLElement | DocumentFragment;
	/**
	 * Returns the property name for the given attribute `name`.
	 * @nocollapse
	 */
	private static __attributeNameForProperty;
	private __updatePromise;
	/**
	 * True if there is a pending update as a result of calling `requestUpdate()`.
	 * Should only be read.
	 * @category updates
	 */
	isUpdatePending: boolean;
	/**
	 * Is set to `true` after the first update. The element code cannot assume
	 * that `renderRoot` exists before the element `hasUpdated`.
	 * @category updates
	 */
	hasUpdated: boolean;
	/**
	 * Properties that should be reflected when updated.
	 */
	private __reflectingProperties?;
	/**
	 * Name of currently reflecting property
	 */
	private __reflectingProperty;
	/**
	 * Set of controllers.
	 */
	private __controllers?;
	constructor();
	/**
	 * Internal only override point for customizing work done when elements
	 * are constructed.
	 */
	private __initialize;
	/**
	 * Registers a `ReactiveController` to participate in the element's reactive
	 * update cycle. The element automatically calls into any registered
	 * controllers during its lifecycle callbacks.
	 *
	 * If the element is connected when `addController()` is called, the
	 * controller's `hostConnected()` callback will be immediately called.
	 * @category controllers
	 */
	addController(controller: ReactiveController): void;
	/**
	 * Removes a `ReactiveController` from the element.
	 * @category controllers
	 */
	removeController(controller: ReactiveController): void;
	/**
	 * Fixes any properties set on the instance before upgrade time.
	 * Otherwise these would shadow the accessor and break these properties.
	 * The properties are stored in a Map which is played back after the
	 * constructor runs. Note, on very old versions of Safari (<=9) or Chrome
	 * (<=41), properties created for native platform properties like (`id` or
	 * `name`) may not have default values set in the element constructor. On
	 * these browsers native properties appear on instances and therefore their
	 * default value will overwrite any element default (e.g. if the element sets
	 * this.id = 'id' in the constructor, the 'id' will become '' since this is
	 * the native platform default).
	 */
	private __saveInstanceProperties;
	/**
	 * Returns the node into which the element should render and by default
	 * creates and returns an open shadowRoot. Implement to customize where the
	 * element's DOM is rendered. For example, to render into the element's
	 * childNodes, return `this`.
	 *
	 * @return Returns a node into which to render.
	 * @category rendering
	 */
	protected createRenderRoot(): HTMLElement | DocumentFragment;
	/**
	 * On first connection, creates the element's renderRoot, sets up
	 * element styling, and enables updating.
	 * @category lifecycle
	 */
	connectedCallback(): void;
	/**
	 * Note, this method should be considered final and not overridden. It is
	 * overridden on the element instance with a function that triggers the first
	 * update.
	 * @category updates
	 */
	protected enableUpdating(_requestedUpdate: boolean): void;
	/**
	 * Allows for `super.disconnectedCallback()` in extensions while
	 * reserving the possibility of making non-breaking feature additions
	 * when disconnecting at some point in the future.
	 * @category lifecycle
	 */
	disconnectedCallback(): void;
	/**
	 * Synchronizes property values when attributes change.
	 *
	 * Specifically, when an attribute is set, the corresponding property is set.
	 * You should rarely need to implement this callback. If this method is
	 * overridden, `super.attributeChangedCallback(name, _old, value)` must be
	 * called.
	 *
	 * See [using the lifecycle callbacks](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#using_the_lifecycle_callbacks)
	 * on MDN for more information about the `attributeChangedCallback`.
	 * @category attributes
	 */
	attributeChangedCallback(name: string, _old: string | null, value: string | null): void;
	private __propertyToAttribute;
	/**
	 * Requests an update which is processed asynchronously. This should be called
	 * when an element should update based on some state not triggered by setting
	 * a reactive property. In this case, pass no arguments. It should also be
	 * called when manually implementing a property setter. In this case, pass the
	 * property `name` and `oldValue` to ensure that any configured property
	 * options are honored.
	 *
	 * @param name name of requesting property
	 * @param oldValue old value of requesting property
	 * @param options property options to use instead of the previously
	 *     configured options
	 * @category updates
	 */
	requestUpdate(name?: PropertyKey, oldValue?: unknown, options?: PropertyDeclaration): void;
	/**
	 * Sets up the element to asynchronously update.
	 */
	private __enqueueUpdate;
	/**
	 * Schedules an element update. You can override this method to change the
	 * timing of updates by returning a Promise. The update will await the
	 * returned Promise, and you should resolve the Promise to allow the update
	 * to proceed. If this method is overridden, `super.scheduleUpdate()`
	 * must be called.
	 *
	 * For instance, to schedule updates to occur just before the next frame:
	 *
	 * ```ts
	 * override protected async scheduleUpdate(): Promise<unknown> {
	 *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));
	 *   super.scheduleUpdate();
	 * }
	 * ```
	 * @category updates
	 */
	protected scheduleUpdate(): void | Promise<unknown>;
	/**
	 * Performs an element update. Note, if an exception is thrown during the
	 * update, `firstUpdated` and `updated` will not be called.
	 *
	 * Call `performUpdate()` to immediately process a pending update. This should
	 * generally not be needed, but it can be done in rare cases when you need to
	 * update synchronously.
	 *
	 * @category updates
	 */
	protected performUpdate(): void;
	/**
	 * Invoked before `update()` to compute values needed during the update.
	 *
	 * Implement `willUpdate` to compute property values that depend on other
	 * properties and are used in the rest of the update process.
	 *
	 * ```ts
	 * willUpdate(changedProperties) {
	 *   // only need to check changed properties for an expensive computation.
	 *   if (changedProperties.has('firstName') || changedProperties.has('lastName')) {
	 *     this.sha = computeSHA(`${this.firstName} ${this.lastName}`);
	 *   }
	 * }
	 *
	 * render() {
	 *   return html`SHA: ${this.sha}`;
	 * }
	 * ```
	 *
	 * @category updates
	 */
	protected willUpdate(_changedProperties: PropertyValues): void;
	private __markUpdated;
	/**
	 * Returns a Promise that resolves when the element has completed updating.
	 * The Promise value is a boolean that is `true` if the element completed the
	 * update without triggering another update. The Promise result is `false` if
	 * a property was set inside `updated()`. If the Promise is rejected, an
	 * exception was thrown during the update.
	 *
	 * To await additional asynchronous work, override the `getUpdateComplete`
	 * method. For example, it is sometimes useful to await a rendered element
	 * before fulfilling this Promise. To do this, first await
	 * `super.getUpdateComplete()`, then any subsequent state.
	 *
	 * @return A promise of a boolean that resolves to true if the update completed
	 *     without triggering another update.
	 * @category updates
	 */
	get updateComplete(): Promise<boolean>;
	/**
	 * Override point for the `updateComplete` promise.
	 *
	 * It is not safe to override the `updateComplete` getter directly due to a
	 * limitation in TypeScript which means it is not possible to call a
	 * superclass getter (e.g. `super.updateComplete.then(...)`) when the target
	 * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).
	 * This method should be overridden instead. For example:
	 *
	 * ```ts
	 * class MyElement extends LitElement {
	 *   override async getUpdateComplete() {
	 *     const result = await super.getUpdateComplete();
	 *     await this._myChild.updateComplete;
	 *     return result;
	 *   }
	 * }
	 * ```
	 *
	 * @return A promise of a boolean that resolves to true if the update completed
	 *     without triggering another update.
	 * @category updates
	 */
	protected getUpdateComplete(): Promise<boolean>;
	/**
	 * Controls whether or not `update()` should be called when the element requests
	 * an update. By default, this method always returns `true`, but this can be
	 * customized to control when to update.
	 *
	 * @param _changedProperties Map of changed properties with old values
	 * @category updates
	 */
	protected shouldUpdate(_changedProperties: PropertyValues): boolean;
	/**
	 * Updates the element. This method reflects property values to attributes.
	 * It can be overridden to render and keep updated element DOM.
	 * Setting properties inside this method will *not* trigger
	 * another update.
	 *
	 * @param _changedProperties Map of changed properties with old values
	 * @category updates
	 */
	protected update(_changedProperties: PropertyValues): void;
	/**
	 * Invoked whenever the element is updated. Implement to perform
	 * post-updating tasks via DOM APIs, for example, focusing an element.
	 *
	 * Setting properties inside this method will trigger the element to update
	 * again after this update cycle completes.
	 *
	 * @param _changedProperties Map of changed properties with old values
	 * @category updates
	 */
	protected updated(_changedProperties: PropertyValues): void;
	/**
	 * Invoked when the element is first updated. Implement to perform one time
	 * work on the element after update.
	 *
	 * ```ts
	 * firstUpdated() {
	 *   this.renderRoot.getElementById('my-text-area').focus();
	 * }
	 * ```
	 *
	 * Setting properties inside this method will trigger the element to update
	 * again after this update cycle completes.
	 *
	 * @param _changedProperties Map of changed properties with old values
	 * @category updates
	 */
	protected firstUpdated(_changedProperties: PropertyValues): void;
}
export interface DirectiveClass {
	new (part: PartInfo): Directive;
}
/**
 * This utility type extracts the signature of a directive class's render()
 * method so we can use it for the type of the generated directive function.
 */
export type DirectiveParameters<C extends Directive> = Parameters<C["render"]>;
/**
 * A generated directive function doesn't evaluate the directive, but just
 * returns a DirectiveResult object that captures the arguments.
 */
export interface DirectiveResult<C extends DirectiveClass = DirectiveClass> {
}
export declare const PartType: {
	readonly ATTRIBUTE: 1;
	readonly CHILD: 2;
	readonly PROPERTY: 3;
	readonly BOOLEAN_ATTRIBUTE: 4;
	readonly EVENT: 5;
	readonly ELEMENT: 6;
};
export type PartType = (typeof PartType)[keyof typeof PartType];
export interface ChildPartInfo {
	readonly type: typeof PartType.CHILD;
}
export interface AttributePartInfo {
	readonly type: typeof PartType.ATTRIBUTE | typeof PartType.PROPERTY | typeof PartType.BOOLEAN_ATTRIBUTE | typeof PartType.EVENT;
	readonly strings?: ReadonlyArray<string>;
	readonly name: string;
	readonly tagName: string;
}
export interface ElementPartInfo {
	readonly type: typeof PartType.ELEMENT;
}
/**
 * Information about the part a directive is bound to.
 *
 * This is useful for checking that a directive is attached to a valid part,
 * such as with directive that can only be used on attribute bindings.
 */
export type PartInfo = ChildPartInfo | AttributePartInfo | ElementPartInfo;
/**
 * Creates a user-facing directive function from a Directive class. This
 * function has the same parameters as the directive's render() method.
 */
export declare const directive: <C extends DirectiveClass>(c: C) => (...values: DirectiveParameters<InstanceType<C>>) => DirectiveResult<C>;
/**
 * Base class for creating custom directives. Users should extend this class,
 * implement `render` and/or `update`, and then pass their subclass to
 * `directive`.
 */
export declare abstract class Directive implements Disconnectable {
	constructor(_partInfo: PartInfo);
	get _$isConnected(): boolean;
	abstract render(...props: Array<unknown>): unknown;
	update(_part: Part, props: Array<unknown>): unknown;
}
declare class TrustedHTML$1 {
	private constructor(); // To prevent instantiting with 'new'.
	private brand: true; // To prevent structural typing.
}
/**
 * Contains types that are part of the unstable debug API.
 *
 * Everything in this API is not stable and may change or be removed in the future,
 * even on patch releases.
 */
export declare namespace LitUnstable {
	/**
	 * When Lit is running in dev mode and `window.emitLitDebugLogEvents` is true,
	 * we will emit 'lit-debug' events to window, with live details about the update and render
	 * lifecycle. These can be useful for writing debug tooling and visualizations.
	 *
	 * Please be aware that running with window.emitLitDebugLogEvents has performance overhead,
	 * making certain operations that are normally very cheap (like a no-op render) much slower,
	 * because we must copy data and dispatch events.
	 */
	namespace DebugLog {
		type Entry = TemplatePrep | TemplateInstantiated | TemplateInstantiatedAndUpdated | TemplateUpdating | BeginRender | EndRender | CommitPartEntry | SetPartValue;
		interface TemplatePrep {
			kind: "template prep";
			template: Template;
			strings: TemplateStringsArray;
			clonableTemplate: HTMLTemplateElement;
			parts: TemplatePart[];
		}
		interface BeginRender {
			kind: "begin render";
			id: number;
			value: unknown;
			container: HTMLElement | DocumentFragment;
			options: RenderOptions | undefined;
			part: ChildPart | undefined;
		}
		interface EndRender {
			kind: "end render";
			id: number;
			value: unknown;
			container: HTMLElement | DocumentFragment;
			options: RenderOptions | undefined;
			part: ChildPart;
		}
		interface TemplateInstantiated {
			kind: "template instantiated";
			template: Template | CompiledTemplate;
			instance: TemplateInstance;
			options: RenderOptions | undefined;
			fragment: Node;
			parts: Array<Part | undefined>;
			values: unknown[];
		}
		interface TemplateInstantiatedAndUpdated {
			kind: "template instantiated and updated";
			template: Template | CompiledTemplate;
			instance: TemplateInstance;
			options: RenderOptions | undefined;
			fragment: Node;
			parts: Array<Part | undefined>;
			values: unknown[];
		}
		interface TemplateUpdating {
			kind: "template updating";
			template: Template | CompiledTemplate;
			instance: TemplateInstance;
			options: RenderOptions | undefined;
			parts: Array<Part | undefined>;
			values: unknown[];
		}
		interface SetPartValue {
			kind: "set part";
			part: Part;
			value: unknown;
			valueIndex: number;
			values: unknown[];
			templateInstance: TemplateInstance;
		}
		type CommitPartEntry = CommitNothingToChildEntry | CommitText | CommitNode | CommitAttribute | CommitProperty | CommitBooleanAttribute | CommitEventListener | CommitToElementBinding;
		interface CommitNothingToChildEntry {
			kind: "commit nothing to child";
			start: ChildNode;
			end: ChildNode | null;
			parent: Disconnectable | undefined;
			options: RenderOptions | undefined;
		}
		interface CommitText {
			kind: "commit text";
			node: Text;
			value: unknown;
			options: RenderOptions | undefined;
		}
		interface CommitNode {
			kind: "commit node";
			start: Node;
			parent: Disconnectable | undefined;
			value: Node;
			options: RenderOptions | undefined;
		}
		interface CommitAttribute {
			kind: "commit attribute";
			element: Element;
			name: string;
			value: unknown;
			options: RenderOptions | undefined;
		}
		interface CommitProperty {
			kind: "commit property";
			element: Element;
			name: string;
			value: unknown;
			options: RenderOptions | undefined;
		}
		interface CommitBooleanAttribute {
			kind: "commit boolean attribute";
			element: Element;
			name: string;
			value: boolean;
			options: RenderOptions | undefined;
		}
		interface CommitEventListener {
			kind: "commit event listener";
			element: Element;
			name: string;
			value: unknown;
			oldListener: unknown;
			options: RenderOptions | undefined;
			removeListener: boolean;
			addListener: boolean;
		}
		interface CommitToElementBinding {
			kind: "commit to element binding";
			element: Element;
			value: unknown;
			options: RenderOptions | undefined;
		}
	}
}
/**
 * Used to sanitize any value before it is written into the DOM. This can be
 * used to implement a security policy of allowed and disallowed values in
 * order to prevent XSS attacks.
 *
 * One way of using this callback would be to check attributes and properties
 * against a list of high risk fields, and require that values written to such
 * fields be instances of a class which is safe by construction. Closure's Safe
 * HTML Types is one implementation of this technique (
 * https://github.com/google/safe-html-types/blob/master/doc/safehtml-types.md).
 * The TrustedTypes polyfill in API-only mode could also be used as a basis
 * for this technique (https://github.com/WICG/trusted-types).
 *
 * @param node The HTML node (usually either a #text node or an Element) that
 *     is being written to. Note that this is just an exemplar node, the write
 *     may take place against another instance of the same class of node.
 * @param name The name of an attribute or property (for example, 'href').
 * @param type Indicates whether the write that's about to be performed will
 *     be to a property or a node.
 * @return A function that will sanitize this class of writes.
 */
export type SanitizerFactory = (node: Node, name: string, type: "property" | "attribute") => ValueSanitizer;
/**
 * A function which can sanitize values that will be written to a specific kind
 * of DOM sink.
 *
 * See SanitizerFactory.
 *
 * @param value The value to sanitize. Will be the actual value passed into
 *     the lit-html template literal, so this could be of any type.
 * @return The value to write to the DOM. Usually the same as the input value,
 *     unless sanitization is needed.
 */
export type ValueSanitizer = (value: unknown) => unknown;
declare const HTML_RESULT = 1;
declare const SVG_RESULT = 2;
declare const MATHML_RESULT = 3;
export type ResultType = typeof HTML_RESULT | typeof SVG_RESULT | typeof MATHML_RESULT;
declare const ATTRIBUTE_PART = 1;
declare const CHILD_PART = 2;
declare const PROPERTY_PART = 3;
declare const BOOLEAN_ATTRIBUTE_PART = 4;
declare const EVENT_PART = 5;
declare const ELEMENT_PART = 6;
declare const COMMENT_PART = 7;
/**
 * The return type of the template tag functions, {@linkcode html} and
 * {@linkcode svg} when it hasn't been compiled by @lit-labs/compiler.
 *
 * A `TemplateResult` object holds all the information about a template
 * expression required to render it: the template strings, expression values,
 * and type of template (html or svg).
 *
 * `TemplateResult` objects do not create any DOM on their own. To create or
 * update DOM you need to render the `TemplateResult`. See
 * [Rendering](https://lit.dev/docs/components/rendering) for more information.
 *
 */
export type UncompiledTemplateResult<T extends ResultType = ResultType> = {
	["_$litType$"]: T;
	strings: TemplateStringsArray;
	values: unknown[];
};
/**
 * This is a template result that may be either uncompiled or compiled.
 *
 * In the future, TemplateResult will be this type. If you want to explicitly
 * note that a template result is potentially compiled, you can reference this
 * type and it will continue to behave the same through the next major version
 * of Lit. This can be useful for code that wants to prepare for the next
 * major version of Lit.
 */
export type MaybeCompiledTemplateResult<T extends ResultType = ResultType> = UncompiledTemplateResult<T> | CompiledTemplateResult;
/**
 * The return type of the template tag functions, {@linkcode html} and
 * {@linkcode svg}.
 *
 * A `TemplateResult` object holds all the information about a template
 * expression required to render it: the template strings, expression values,
 * and type of template (html or svg).
 *
 * `TemplateResult` objects do not create any DOM on their own. To create or
 * update DOM you need to render the `TemplateResult`. See
 * [Rendering](https://lit.dev/docs/components/rendering) for more information.
 *
 * In Lit 4, this type will be an alias of
 * MaybeCompiledTemplateResult, so that code will get type errors if it assumes
 * that Lit templates are not compiled. When deliberately working with only
 * one, use either {@linkcode CompiledTemplateResult} or
 * {@linkcode UncompiledTemplateResult} explicitly.
 */
export type TemplateResult<T extends ResultType = ResultType> = UncompiledTemplateResult<T>;
export type HTMLTemplateResult = TemplateResult<typeof HTML_RESULT>;
export type SVGTemplateResult = TemplateResult<typeof SVG_RESULT>;
export type MathMLTemplateResult = TemplateResult<typeof MATHML_RESULT>;
/**
 * A TemplateResult that has been compiled by @lit-labs/compiler, skipping the
 * prepare step.
 */
export interface CompiledTemplateResult {
	["_$litType$"]: CompiledTemplate;
	values: unknown[];
}
export interface CompiledTemplate extends Omit<Template, "el"> {
	el?: HTMLTemplateElement;
	h: TemplateStringsArray;
}
/**
 * Interprets a template literal as an HTML template that can efficiently
 * render to and update a container.
 *
 * ```ts
 * const header = (title: string) => html`<h1>${title}</h1>`;
 * ```
 *
 * The `html` tag returns a description of the DOM to render as a value. It is
 * lazy, meaning no work is done until the template is rendered. When rendering,
 * if a template comes from the same expression as a previously rendered result,
 * it's efficiently updated instead of replaced.
 */
export declare const html: (strings: TemplateStringsArray, ...values: unknown[]) => TemplateResult<1>;
/**
 * Interprets a template literal as an SVG fragment that can efficiently render
 * to and update a container.
 *
 * ```ts
 * const rect = svg`<rect width="10" height="10"></rect>`;
 *
 * const myImage = html`
 *   <svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg">
 *     ${rect}
 *   </svg>`;
 * ```
 *
 * The `svg` *tag function* should only be used for SVG fragments, or elements
 * that would be contained **inside** an `<svg>` HTML element. A common error is
 * placing an `<svg>` *element* in a template tagged with the `svg` tag
 * function. The `<svg>` element is an HTML element and should be used within a
 * template tagged with the {@linkcode html} tag function.
 *
 * In LitElement usage, it's invalid to return an SVG fragment from the
 * `render()` method, as the SVG fragment will be contained within the element's
 * shadow root and thus not be properly contained within an `<svg>` HTML
 * element.
 */
export declare const svg: (strings: TemplateStringsArray, ...values: unknown[]) => TemplateResult<2>;
/**
 * Interprets a template literal as MathML fragment that can efficiently render
 * to and update a container.
 *
 * ```ts
 * const num = mathml`<mn>1</mn>`;
 *
 * const eq = html`
 *   <math>
 *     ${num}
 *   </math>`;
 * ```
 *
 * The `mathml` *tag function* should only be used for MathML fragments, or
 * elements that would be contained **inside** a `<math>` HTML element. A common
 * error is placing a `<math>` *element* in a template tagged with the `mathml`
 * tag function. The `<math>` element is an HTML element and should be used
 * within a template tagged with the {@linkcode html} tag function.
 *
 * In LitElement usage, it's invalid to return an MathML fragment from the
 * `render()` method, as the MathML fragment will be contained within the
 * element's shadow root and thus not be properly contained within a `<math>`
 * HTML element.
 */
export declare const mathml: (strings: TemplateStringsArray, ...values: unknown[]) => TemplateResult<3>;
/**
 * A sentinel value that signals that a value was handled by a directive and
 * should not be written to the DOM.
 */
export declare const noChange: unique symbol;
/**
 * A sentinel value that signals a ChildPart to fully clear its content.
 *
 * ```ts
 * const button = html`${
 *  user.isAdmin
 *    ? html`<button>DELETE</button>`
 *    : nothing
 * }`;
 * ```
 *
 * Prefer using `nothing` over other falsy values as it provides a consistent
 * behavior between various expression binding contexts.
 *
 * In child expressions, `undefined`, `null`, `''`, and `nothing` all behave the
 * same and render no nodes. In attribute expressions, `nothing` _removes_ the
 * attribute, while `undefined` and `null` will render an empty string. In
 * property expressions `nothing` becomes `undefined`.
 */
export declare const nothing: unique symbol;
/**
 * Object specifying options for controlling lit-html rendering. Note that
 * while `render` may be called multiple times on the same `container` (and
 * `renderBefore` reference node) to efficiently update the rendered content,
 * only the options passed in during the first render are respected during
 * the lifetime of renders to that unique `container` + `renderBefore`
 * combination.
 */
export interface RenderOptions {
	/**
	 * An object to use as the `this` value for event listeners. It's often
	 * useful to set this to the host component rendering a template.
	 */
	host?: object;
	/**
	 * A DOM node before which to render content in the container.
	 */
	renderBefore?: ChildNode | null;
	/**
	 * Node used for cloning the template (`importNode` will be called on this
	 * node). This controls the `ownerDocument` of the rendered DOM, along with
	 * any inherited context. Defaults to the global `document`.
	 */
	creationScope?: {
		importNode(node: Node, deep?: boolean): Node;
	};
	/**
	 * The initial connected state for the top-level part being rendered. If no
	 * `isConnected` option is set, `AsyncDirective`s will be connected by
	 * default. Set to `false` if the initial render occurs in a disconnected tree
	 * and `AsyncDirective`s should see `isConnected === false` for their initial
	 * render. The `part.setConnected()` method must be used subsequent to initial
	 * render to change the connected state of the part.
	 */
	isConnected?: boolean;
}
export interface DirectiveParent {
	_$parent?: DirectiveParent;
	_$isConnected: boolean;
	__directive?: Directive;
	__directives?: Array<Directive | undefined>;
}
declare class Template {
	parts: Array<TemplatePart>;
	constructor({ strings, ["_$litType$"]: type }: UncompiledTemplateResult, options?: RenderOptions);
	/** @nocollapse */
	static createElement(html: TrustedHTML$1, _options?: RenderOptions): HTMLTemplateElement;
}
export interface Disconnectable {
	_$parent?: Disconnectable;
	_$disconnectableChildren?: Set<Disconnectable>;
	_$isConnected: boolean;
}
declare function resolveDirective(part: ChildPart | AttributePart | ElementPart, value: unknown, parent?: DirectiveParent, attributeIndex?: number): unknown;
/**
 * An updateable instance of a Template. Holds references to the Parts used to
 * update the template instance.
 */
export declare class TemplateInstance implements Disconnectable {
	_$template: Template;
	_$parts: Array<Part | undefined>;
	constructor(template: Template, parent: ChildPart);
	get parentNode(): Node;
	get _$isConnected(): boolean;
	_clone(options: RenderOptions | undefined): Node;
	_update(values: Array<unknown>): void;
}
export type AttributeTemplatePart = {
	readonly type: typeof ATTRIBUTE_PART;
	readonly index: number;
	readonly name: string;
	readonly ctor: typeof AttributePart;
	readonly strings: ReadonlyArray<string>;
};
export type ChildTemplatePart = {
	readonly type: typeof CHILD_PART;
	readonly index: number;
};
export type ElementTemplatePart = {
	readonly type: typeof ELEMENT_PART;
	readonly index: number;
};
export type CommentTemplatePart = {
	readonly type: typeof COMMENT_PART;
	readonly index: number;
};
/**
 * A TemplatePart represents a dynamic part in a template, before the template
 * is instantiated. When a template is instantiated Parts are created from
 * TemplateParts.
 */
export type TemplatePart = ChildTemplatePart | AttributeTemplatePart | ElementTemplatePart | CommentTemplatePart;
export type Part = ChildPart | AttributePart | PropertyPart | BooleanAttributePart | ElementPart | EventPart;
export declare class ChildPart implements Disconnectable {
	readonly type = 2;
	readonly options: RenderOptions | undefined;
	_$committedValue: unknown;
	private _textSanitizer;
	get _$isConnected(): boolean;
	constructor(startNode: ChildNode, endNode: ChildNode | null, parent: TemplateInstance | ChildPart | undefined, options: RenderOptions | undefined);
	/**
	 * The parent node into which the part renders its content.
	 *
	 * A ChildPart's content consists of a range of adjacent child nodes of
	 * `.parentNode`, possibly bordered by 'marker nodes' (`.startNode` and
	 * `.endNode`).
	 *
	 * - If both `.startNode` and `.endNode` are non-null, then the part's content
	 * consists of all siblings between `.startNode` and `.endNode`, exclusively.
	 *
	 * - If `.startNode` is non-null but `.endNode` is null, then the part's
	 * content consists of all siblings following `.startNode`, up to and
	 * including the last child of `.parentNode`. If `.endNode` is non-null, then
	 * `.startNode` will always be non-null.
	 *
	 * - If both `.endNode` and `.startNode` are null, then the part's content
	 * consists of all child nodes of `.parentNode`.
	 */
	get parentNode(): Node;
	/**
	 * The part's leading marker node, if any. See `.parentNode` for more
	 * information.
	 */
	get startNode(): Node | null;
	/**
	 * The part's trailing marker node, if any. See `.parentNode` for more
	 * information.
	 */
	get endNode(): Node | null;
	_$setValue(value: unknown, directiveParent?: DirectiveParent): void;
	private _insert;
	private _commitNode;
	private _commitText;
	private _commitTemplateResult;
	private _commitIterable;
}
/**
 * A top-level `ChildPart` returned from `render` that manages the connected
 * state of `AsyncDirective`s created throughout the tree below it.
 */
export interface RootPart extends ChildPart {
	/**
	 * Sets the connection state for `AsyncDirective`s contained within this root
	 * ChildPart.
	 *
	 * lit-html does not automatically monitor the connectedness of DOM rendered;
	 * as such, it is the responsibility of the caller to `render` to ensure that
	 * `part.setConnected(false)` is called before the part object is potentially
	 * discarded, to ensure that `AsyncDirective`s have a chance to dispose of
	 * any resources being held. If a `RootPart` that was previously
	 * disconnected is subsequently re-connected (and its `AsyncDirective`s should
	 * re-connect), `setConnected(true)` should be called.
	 *
	 * @param isConnected Whether directives within this tree should be connected
	 * or not
	 */
	setConnected(isConnected: boolean): void;
}
export declare class AttributePart implements Disconnectable {
	readonly type: typeof ATTRIBUTE_PART | typeof PROPERTY_PART | typeof BOOLEAN_ATTRIBUTE_PART | typeof EVENT_PART;
	readonly element: HTMLElement;
	readonly name: string;
	readonly options: RenderOptions | undefined;
	/**
	 * If this attribute part represents an interpolation, this contains the
	 * static strings of the interpolation. For single-value, complete bindings,
	 * this is undefined.
	 */
	readonly strings?: ReadonlyArray<string>;
	protected _sanitizer: ValueSanitizer | undefined;
	get tagName(): string;
	get _$isConnected(): boolean;
	constructor(element: HTMLElement, name: string, strings: ReadonlyArray<string>, parent: Disconnectable, options: RenderOptions | undefined);
}
export declare class PropertyPart extends AttributePart {
	readonly type = 3;
}
export declare class BooleanAttributePart extends AttributePart {
	readonly type = 4;
}
export declare class EventPart extends AttributePart {
	readonly type = 5;
	constructor(element: HTMLElement, name: string, strings: ReadonlyArray<string>, parent: Disconnectable, options: RenderOptions | undefined);
	handleEvent(event: Event): void;
}
export declare class ElementPart implements Disconnectable {
	element: Element;
	readonly type = 6;
	_$committedValue: undefined;
	options: RenderOptions | undefined;
	constructor(element: Element, parent: Disconnectable, options: RenderOptions | undefined);
	get _$isConnected(): boolean;
	_$setValue(value: unknown): void;
}
/**
 * END USERS SHOULD NOT RELY ON THIS OBJECT.
 *
 * Private exports for use by other Lit packages, not intended for use by
 * external users.
 *
 * We currently do not make a mangled rollup build of the lit-ssr code. In order
 * to keep a number of (otherwise private) top-level exports mangled in the
 * client side code, we export a _$LH object containing those members (or
 * helper methods for accessing private fields of those members), and then
 * re-export them for use in lit-ssr. This keeps lit-ssr agnostic to whether the
 * client-side code is being used in `dev` mode or `prod` mode.
 *
 * This has a unique name, to disambiguate it from private exports in
 * lit-element, which re-exports all of lit-html.
 *
 * @private
 */
export declare const _$LH: {
	_boundAttributeSuffix: string;
	_marker: string;
	_markerMatch: string;
	_HTML_RESULT: number;
	_getTemplateHtml: (strings: TemplateStringsArray, type: ResultType) => [
		TrustedHTML$1,
		Array<string>
	];
	_TemplateInstance: typeof TemplateInstance;
	_isIterable: (value: unknown) => value is Iterable<unknown>;
	_resolveDirective: typeof resolveDirective;
	_ChildPart: typeof ChildPart;
	_AttributePart: typeof AttributePart;
	_BooleanAttributePart: typeof BooleanAttributePart;
	_EventPart: typeof EventPart;
	_PropertyPart: typeof PropertyPart;
	_ElementPart: typeof ElementPart;
};
/**
 * Renders a value, usually a lit-html TemplateResult, to the container.
 *
 * This example renders the text "Hello, Zoe!" inside a paragraph tag, appending
 * it to the container `document.body`.
 *
 * ```js
 * import {html, render} from 'lit';
 *
 * const name = "Zoe";
 * render(html`<p>Hello, ${name}!</p>`, document.body);
 * ```
 *
 * @param value Any [renderable
 *   value](https://lit.dev/docs/templates/expressions/#child-expressions),
 *   typically a {@linkcode TemplateResult} created by evaluating a template tag
 *   like {@linkcode html} or {@linkcode svg}.
 * @param container A DOM container to render to. The first render will append
 *   the rendered value to the container, and subsequent renders will
 *   efficiently update the rendered value if the same result type was
 *   previously rendered there.
 * @param options See {@linkcode RenderOptions} for options documentation.
 * @see
 * {@link https://lit.dev/docs/libraries/standalone-templates/#rendering-lit-html-templates| Rendering Lit HTML Templates}
 */
export declare const render: {
	(value: unknown, container: HTMLElement | DocumentFragment, options?: RenderOptions): RootPart;
	setSanitizer: (newSanitizer: SanitizerFactory) => void;
	createSanitizer: SanitizerFactory;
	_testOnlyClearSanitizerFactoryDoNotCallOrElse: () => void;
};
/**
 * Contains types that are part of the unstable debug API.
 *
 * Everything in this API is not stable and may change or be removed in the future,
 * even on patch releases.
 */
export declare namespace Unstable {
	/**
	 * When Lit is running in dev mode and `window.emitLitDebugLogEvents` is true,
	 * we will emit 'lit-debug' events to window, with live details about the update and render
	 * lifecycle. These can be useful for writing debug tooling and visualizations.
	 *
	 * Please be aware that running with window.emitLitDebugLogEvents has performance overhead,
	 * making certain operations that are normally very cheap (like a no-op render) much slower,
	 * because we must copy data and dispatch events.
	 */
	namespace DebugLog {
		type Entry = LitUnstable.DebugLog.Entry | ReactiveUnstable.DebugLog.Entry;
	}
}
/**
 * Base element class that manages element properties and attributes, and
 * renders a lit-html template.
 *
 * To define a component, subclass `LitElement` and implement a
 * `render` method to provide the component's template. Define properties
 * using the {@linkcode LitElement.properties properties} property or the
 * {@linkcode property} decorator.
 */
export declare class LitElement extends ReactiveElement {
	static ["_$litElement$"]: boolean;
	/**
	 * @category rendering
	 */
	readonly renderOptions: RenderOptions;
	private __childPart;
	/**
	 * @category rendering
	 */
	protected createRenderRoot(): HTMLElement | DocumentFragment;
	/**
	 * Updates the element. This method reflects property values to attributes
	 * and calls `render` to render DOM via lit-html. Setting properties inside
	 * this method will *not* trigger another update.
	 * @param changedProperties Map of changed properties with old values
	 * @category updates
	 */
	protected update(changedProperties: PropertyValues): void;
	/**
	 * Invoked when the component is added to the document's DOM.
	 *
	 * In `connectedCallback()` you should setup tasks that should only occur when
	 * the element is connected to the document. The most common of these is
	 * adding event listeners to nodes external to the element, like a keydown
	 * event handler added to the window.
	 *
	 * ```ts
	 * connectedCallback() {
	 *   super.connectedCallback();
	 *   addEventListener('keydown', this._handleKeydown);
	 * }
	 * ```
	 *
	 * Typically, anything done in `connectedCallback()` should be undone when the
	 * element is disconnected, in `disconnectedCallback()`.
	 *
	 * @category lifecycle
	 */
	connectedCallback(): void;
	/**
	 * Invoked when the component is removed from the document's DOM.
	 *
	 * This callback is the main signal to the element that it may no longer be
	 * used. `disconnectedCallback()` should ensure that nothing is holding a
	 * reference to the element (such as event listeners added to nodes external
	 * to the element), so that it is free to be garbage collected.
	 *
	 * ```ts
	 * disconnectedCallback() {
	 *   super.disconnectedCallback();
	 *   window.removeEventListener('keydown', this._handleKeydown);
	 * }
	 * ```
	 *
	 * An element may be re-connected after being disconnected.
	 *
	 * @category lifecycle
	 */
	disconnectedCallback(): void;
	/**
	 * Invoked on each update to perform rendering tasks. This method may return
	 * any value renderable by lit-html's `ChildPart` - typically a
	 * `TemplateResult`. Setting properties inside this method will *not* trigger
	 * the element to update.
	 * @category rendering
	 */
	protected render(): unknown;
}
/**
 * END USERS SHOULD NOT RELY ON THIS OBJECT.
 *
 * Private exports for use by other Lit packages, not intended for use by
 * external users.
 *
 * We currently do not make a mangled rollup build of the lit-ssr code. In order
 * to keep a number of (otherwise private) top-level exports  mangled in the
 * client side code, we export a _$LE object containing those members (or
 * helper methods for accessing private fields of those members), and then
 * re-export them for use in lit-ssr. This keeps lit-ssr agnostic to whether the
 * client-side code is being used in `dev` mode or `prod` mode.
 *
 * This has a unique name, to disambiguate it from private exports in
 * lit-html, since this module re-exports all of lit-html.
 *
 * @private
 */
export declare const _$LE: {
	_$attributeToProperty: (el: LitElement, name: string, value: string | null) => void;
	_$changedProperties: (el: LitElement) => any;
};
/**
 * @license
 * Copyright 2022 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * A boolean that will be `true` in server environments like Node, and `false`
 * in browser environments. Note that your server environment or toolchain must
 * support the `"node"` export condition for this to be `true`.
 *
 * This can be used when authoring components to change behavior based on
 * whether or not the component is executing in an SSR context.
 */
export declare const isServer = false;
/**
 * An abstract `Directive` base class whose `disconnected` method will be
 * called when the part containing the directive is cleared as a result of
 * re-rendering, or when the user calls `part.setConnected(false)` on
 * a part that was previously rendered containing the directive (as happens
 * when e.g. a LitElement disconnects from the DOM).
 *
 * If `part.setConnected(true)` is subsequently called on a
 * containing part, the directive's `reconnected` method will be called prior
 * to its next `update`/`render` callbacks. When implementing `disconnected`,
 * `reconnected` should also be implemented to be compatible with reconnection.
 *
 * Note that updates may occur while the directive is disconnected. As such,
 * directives should generally check the `this.isConnected` flag during
 * render/update to determine whether it is safe to subscribe to resources
 * that may prevent garbage collection.
 */
export declare abstract class AsyncDirective extends Directive {
	/**
	 * The connection state for this Directive.
	 */
	isConnected: boolean;
	/**
	 * Initialize the part with internal fields
	 * @param part
	 * @param parent
	 * @param attributeIndex
	 */
	_$initialize(part: Part, parent: Disconnectable, attributeIndex: number | undefined): void;
	/**
	 * Sets the value of the directive's Part outside the normal `update`/`render`
	 * lifecycle of a directive.
	 *
	 * This method should not be called synchronously from a directive's `update`
	 * or `render`.
	 *
	 * @param directive The directive to update
	 * @param value The value to set
	 */
	setValue(value: unknown): void;
	/**
	 * User callbacks for implementing logic to release any resources/subscriptions
	 * that may have been retained by this directive. Since directives may also be
	 * re-connected, `reconnected` should also be implemented to restore the
	 * working state of the directive prior to the next render.
	 */
	protected disconnected(): void;
	protected reconnected(): void;
}
export type Primitive = null | undefined | boolean | number | string | symbol | bigint;
declare const ChildPart$1: typeof ChildPart;
type ChildPart$1 = InstanceType<typeof ChildPart$1>;
/**
 * Tests if a value is a primitive value.
 *
 * See https://tc39.github.io/ecma262/#sec-typeof-operator
 */
export declare const isPrimitive: (value: unknown) => value is Primitive;
export declare const TemplateResultType: {
	readonly HTML: 1;
	readonly SVG: 2;
	readonly MATHML: 3;
};
export type TemplateResultType = (typeof TemplateResultType)[keyof typeof TemplateResultType];
export type IsTemplateResult = {
	(val: unknown): val is MaybeCompiledTemplateResult;
	<T extends TemplateResultType>(val: unknown, type: T): val is UncompiledTemplateResult<T>;
};
/**
 * Tests if a value is a TemplateResult or a CompiledTemplateResult.
 */
export declare const isTemplateResult: IsTemplateResult;
/**
 * Tests if a value is a CompiledTemplateResult.
 */
export declare const isCompiledTemplateResult: (value: unknown) => value is CompiledTemplateResult;
/**
 * Tests if a value is a DirectiveResult.
 */
export declare const isDirectiveResult: (value: unknown) => value is DirectiveResult;
/**
 * Retrieves the Directive class for a DirectiveResult
 */
export declare const getDirectiveClass: (value: unknown) => DirectiveClass | undefined;
/**
 * Tests whether a part has only a single-expression with no strings to
 * interpolate between.
 *
 * Only AttributePart and PropertyPart can have multiple expressions.
 * Multi-expression parts have a `strings` property and single-expression
 * parts do not.
 */
export declare const isSingleExpression: (part: PartInfo) => boolean;
/**
 * Inserts a ChildPart into the given container ChildPart's DOM, either at the
 * end of the container ChildPart, or before the optional `refPart`.
 *
 * This does not add the part to the containerPart's committed value. That must
 * be done by callers.
 *
 * @param containerPart Part within which to add the new ChildPart
 * @param refPart Part before which to add the new ChildPart; when omitted the
 *     part added to the end of the `containerPart`
 * @param part Part to insert, or undefined to create a new part
 */
export declare const insertPart: (containerPart: ChildPart$1, refPart?: ChildPart$1, part?: ChildPart$1) => ChildPart$1;
/**
 * Sets the value of a Part.
 *
 * Note that this should only be used to set/update the value of user-created
 * parts (i.e. those created using `insertPart`); it should not be used
 * by directives to set the value of the directive's container part. Directives
 * should return a value from `update`/`render` to update their part state.
 *
 * For directives that require setting their part value asynchronously, they
 * should extend `AsyncDirective` and call `this.setValue()`.
 *
 * @param part Part to set
 * @param value Value to set
 * @param index For `AttributePart`s, the index to set
 * @param directiveParent Used internally; should not be set by user
 */
export declare const setChildPartValue: <T extends ChildPart$1>(part: T, value: unknown, directiveParent?: DirectiveParent) => T;
/**
 * Sets the committed value of a ChildPart directly without triggering the
 * commit stage of the part.
 *
 * This is useful in cases where a directive needs to update the part such
 * that the next update detects a value change or not. When value is omitted,
 * the next update will be guaranteed to be detected as a change.
 *
 * @param part
 * @param value
 */
export declare const setCommittedValue: (part: Part, value?: unknown) => unknown;
/**
 * Returns the committed value of a ChildPart.
 *
 * The committed value is used for change detection and efficient updates of
 * the part. It can differ from the value set by the template or directive in
 * cases where the template value is transformed before being committed.
 *
 * - `TemplateResult`s are committed as a `TemplateInstance`
 * - Iterables are committed as `Array<ChildPart>`
 * - All other types are committed as the template value or value returned or
 *   set by a directive.
 *
 * @param part
 */
export declare const getCommittedValue: (part: ChildPart$1) => unknown;
/**
 * Removes a ChildPart from the DOM, including any of its content.
 *
 * @param part The Part to remove
 */
export declare const removePart: (part: ChildPart$1) => void;
export declare const clearPart: (part: ChildPart$1) => void;
export type Mapper<T> = (v: T, index?: number) => unknown;
export declare class AsyncReplaceDirective extends AsyncDirective {
	private __value?;
	private __weakThis;
	private __pauser;
	render<T>(value: AsyncIterable<T>, _mapper?: Mapper<T>): symbol;
	update(_part: ChildPart, [value, mapper]: DirectiveParameters<this>): symbol;
	protected commitValue(value: unknown, _index: number): void;
	disconnected(): void;
	reconnected(): void;
}
/**
 * A directive that renders the items of an async iterable[1], replacing
 * previous values with new values, so that only one value is ever rendered
 * at a time. This directive may be used in any expression type.
 *
 * Async iterables are objects with a `[Symbol.asyncIterator]` method, which
 * returns an iterator who's `next()` method returns a Promise. When a new
 * value is available, the Promise resolves and the value is rendered to the
 * Part controlled by the directive. If another value other than this
 * directive has been set on the Part, the iterable will no longer be listened
 * to and new values won't be written to the Part.
 *
 * [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of
 *
 * @param value An async iterable
 * @param mapper An optional function that maps from (value, index) to another
 *     value. Useful for generating templates for each item in the iterable.
 */
export declare const asyncReplace: (value: AsyncIterable<unknown>, _mapper?: Mapper<unknown> | undefined) => DirectiveResult<typeof AsyncReplaceDirective>;
export declare class AsyncAppendDirective extends AsyncReplaceDirective {
	private __childPart;
	constructor(partInfo: PartInfo);
	update(part: ChildPart, params: DirectiveParameters<this>): symbol;
	protected commitValue(value: unknown, index: number): void;
}
/**
 * A directive that renders the items of an async iterable[1], appending new
 * values after previous values, similar to the built-in support for iterables.
 * This directive is usable only in child expressions.
 *
 * Async iterables are objects with a [Symbol.asyncIterator] method, which
 * returns an iterator who's `next()` method returns a Promise. When a new
 * value is available, the Promise resolves and the value is appended to the
 * Part controlled by the directive. If another value other than this
 * directive has been set on the Part, the iterable will no longer be listened
 * to and new values won't be written to the Part.
 *
 * [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of
 *
 * @param value An async iterable
 * @param mapper An optional function that maps from (value, index) to another
 *     value. Useful for generating templates for each item in the iterable.
 */
export declare const asyncAppend: (value: AsyncIterable<unknown>, _mapper?: ((v: unknown, index?: number) => unknown) | undefined) => DirectiveResult<typeof AsyncAppendDirective>;
export declare class CacheDirective extends Directive {
	private _templateCache;
	private _value?;
	constructor(partInfo: PartInfo);
	render(v: unknown): unknown[];
	update(containerPart: ChildPart, [v]: DirectiveParameters<this>): unknown[];
}
/**
 * Enables fast switching between multiple templates by caching the DOM nodes
 * and TemplateInstances produced by the templates.
 *
 * Example:
 *
 * ```js
 * let checked = false;
 *
 * html`
 *   ${cache(checked ? html`input is checked` : html`input is not checked`)}
 * `
 * ```
 */
export declare const cache: (v: unknown) => DirectiveResult<typeof CacheDirective>;
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * Chooses and evaluates a template function from a list based on matching
 * the given `value` to a case.
 *
 * Cases are structured as `[caseValue, func]`. `value` is matched to
 * `caseValue` by strict equality. The first match is selected. Case values
 * can be of any type including primitives, objects, and symbols.
 *
 * This is similar to a switch statement, but as an expression and without
 * fallthrough.
 *
 * @example
 *
 * ```ts
 * render() {
 *   return html`
 *     ${choose(this.section, [
 *       ['home', () => html`<h1>Home</h1>`],
 *       ['about', () => html`<h1>About</h1>`]
 *     ],
 *     () => html`<h1>Error</h1>`)}
 *   `;
 * }
 * ```
 */
export declare const choose: <T, V, K extends T = T>(value: T, cases: Array<[
	K,
	() => V
]>, defaultCase?: () => V) => V | undefined;
/**
 * A key-value set of class names to truthy values.
 */
export interface ClassInfo {
	readonly [name: string]: string | boolean | number;
}
export declare class ClassMapDirective extends Directive {
	/**
	 * Stores the ClassInfo object applied to a given AttributePart.
	 * Used to unset existing values when a new ClassInfo object is applied.
	 */
	private _previousClasses?;
	private _staticClasses?;
	constructor(partInfo: PartInfo);
	render(classInfo: ClassInfo): string;
	update(part: AttributePart, [classInfo]: DirectiveParameters<this>): string | typeof noChange;
}
/**
 * A directive that applies dynamic CSS classes.
 *
 * This must be used in the `class` attribute and must be the only part used in
 * the attribute. It takes each property in the `classInfo` argument and adds
 * the property name to the element's `classList` if the property value is
 * truthy; if the property value is falsy, the property name is removed from
 * the element's `class`.
 *
 * For example `{foo: bar}` applies the class `foo` if the value of `bar` is
 * truthy.
 *
 * @param classInfo
 */
export declare const classMap: (classInfo: ClassInfo) => DirectiveResult<typeof ClassMapDirective>;
export declare class GuardDirective extends Directive {
	private _previousValue;
	render(_value: unknown, f: () => unknown): unknown;
	update(_part: Part, [value, f]: DirectiveParameters<this>): unknown;
}
/**
 * Prevents re-render of a template function until a single value or an array of
 * values changes.
 *
 * Values are checked against previous values with strict equality (`===`), and
 * so the check won't detect nested property changes inside objects or arrays.
 * Arrays values have each item checked against the previous value at the same
 * index with strict equality. Nested arrays are also checked only by strict
 * equality.
 *
 * Example:
 *
 * ```js
 * html`
 *   <div>
 *     ${guard([user.id, company.id], () => html`...`)}
 *   </div>
 * `
 * ```
 *
 * In this case, the template only rerenders if either `user.id` or `company.id`
 * changes.
 *
 * guard() is useful with immutable data patterns, by preventing expensive work
 * until data updates.
 *
 * Example:
 *
 * ```js
 * html`
 *   <div>
 *     ${guard([immutableItems], () => immutableItems.map(i => html`${i}`))}
 *   </div>
 * `
 * ```
 *
 * In this case, items are mapped over only when the array reference changes.
 *
 * @param value the value to check before re-rendering
 * @param f the template function
 */
export declare const guard: (_value: unknown, f: () => unknown) => DirectiveResult<typeof GuardDirective>;
/**
 * For AttributeParts, sets the attribute if the value is defined and removes
 * the attribute if the value is undefined.
 *
 * For other part types, this directive is a no-op.
 */
export declare const ifDefined: <T>(value: T) => typeof nothing | NonNullable<T>;
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * Returns an iterable containing the values in `items` interleaved with the
 * `joiner` value.
 *
 * @example
 *
 * ```ts
 * render() {
 *   return html`
 *     ${join(items, html`<span class="separator">|</span>`)}
 *   `;
 * }
 */
export declare function join<I, J>(items: Iterable<I> | undefined, joiner: (index: number) => J): Iterable<I | J>;
export declare function join<I, J>(items: Iterable<I> | undefined, joiner: J): Iterable<I | J>;
export declare class Keyed extends Directive {
	key: unknown;
	render(k: unknown, v: unknown): unknown;
	update(part: ChildPart, [k, v]: DirectiveParameters<this>): unknown;
}
/**
 * Associates a renderable value with a unique key. When the key changes, the
 * previous DOM is removed and disposed before rendering the next value, even
 * if the value - such as a template - is the same.
 *
 * This is useful for forcing re-renders of stateful components, or working
 * with code that expects new data to generate new HTML elements, such as some
 * animation techniques.
 */
export declare const keyed: (k: unknown, v: unknown) => DirectiveResult<typeof Keyed>;
export declare class LiveDirective extends Directive {
	constructor(partInfo: PartInfo);
	render(value: unknown): unknown;
	update(part: AttributePart, [value]: DirectiveParameters<this>): unknown;
}
/**
 * Checks binding values against live DOM values, instead of previously bound
 * values, when determining whether to update the value.
 *
 * This is useful for cases where the DOM value may change from outside of
 * lit-html, such as with a binding to an `<input>` element's `value` property,
 * a content editable elements text, or to a custom element that changes it's
 * own properties or attributes.
 *
 * In these cases if the DOM value changes, but the value set through lit-html
 * bindings hasn't, lit-html won't know to update the DOM value and will leave
 * it alone. If this is not what you want--if you want to overwrite the DOM
 * value with the bound value no matter what--use the `live()` directive:
 *
 * ```js
 * html`<input .value=${live(x)}>`
 * ```
 *
 * `live()` performs a strict equality check against the live DOM value, and if
 * the new value is equal to the live value, does nothing. This means that
 * `live()` should not be used when the binding will cause a type conversion. If
 * you use `live()` with an attribute binding, make sure that only strings are
 * passed in, or the binding will update every render.
 */
export declare const live: (value: unknown) => DirectiveResult<typeof LiveDirective>;
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * Returns an iterable containing the result of calling `f(value)` on each
 * value in `items`.
 *
 * @example
 *
 * ```ts
 * render() {
 *   return html`
 *     <ul>
 *       ${map(items, (i) => html`<li>${i}</li>`)}
 *     </ul>
 *   `;
 * }
 * ```
 */
export declare function map<T>(items: Iterable<T> | undefined, f: (value: T, index: number) => unknown): Generator<unknown, void, unknown>;
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * Returns an iterable of integers from `start` to `end` (exclusive)
 * incrementing by `step`.
 *
 * If `start` is omitted, the range starts at `0`. `step` defaults to `1`.
 *
 * @example
 *
 * ```ts
 * render() {
 *   return html`
 *     ${map(range(8), () => html`<div class="cell"></div>`)}
 *   `;
 * }
 * ```
 */
export declare function range(end: number): Iterable<number>;
export declare function range(start: number, end: number, step?: number): Iterable<number>;
/**
 * Creates a new Ref object, which is container for a reference to an element.
 */
export declare const createRef: <T = Element>() => Ref<T>;
/**
 * An object that holds a ref value.
 */
export declare class Ref<T = Element> {
	/**
	 * The current Element value of the ref, or else `undefined` if the ref is no
	 * longer rendered.
	 */
	readonly value?: T;
}
export type RefOrCallback<T = Element> = Ref<T> | ((el: T | undefined) => void);
export declare class RefDirective extends AsyncDirective {
	private _element?;
	private _ref?;
	private _context?;
	render(_ref?: RefOrCallback): symbol;
	update(part: ElementPart, [ref]: Parameters<this["render"]>): symbol;
	private _updateRefValue;
	private get _lastElementForRef();
	disconnected(): void;
	reconnected(): void;
}
/**
 * Sets the value of a Ref object or calls a ref callback with the element it's
 * bound to.
 *
 * A Ref object acts as a container for a reference to an element. A ref
 * callback is a function that takes an element as its only argument.
 *
 * The ref directive sets the value of the Ref object or calls the ref callback
 * during rendering, if the referenced element changed.
 *
 * Note: If a ref callback is rendered to a different element position or is
 * removed in a subsequent render, it will first be called with `undefined`,
 * followed by another call with the new element it was rendered to (if any).
 *
 * ```js
 * // Using Ref object
 * const inputRef = createRef();
 * render(html`<input ${ref(inputRef)}>`, container);
 * inputRef.value.focus();
 *
 * // Using callback
 * const callback = (inputElement) => inputElement.focus();
 * render(html`<input ${ref(callback)}>`, container);
 * ```
 */
export declare const ref: (_ref?: RefOrCallback<Element> | undefined) => DirectiveResult<typeof RefDirective>;
export type KeyFn<T> = (item: T, index: number) => unknown;
export type ItemTemplate<T> = (item: T, index: number) => unknown;
export declare class RepeatDirective extends Directive {
	private _itemKeys?;
	constructor(partInfo: PartInfo);
	private _getValuesAndKeys;
	render<T>(items: Iterable<T>, template: ItemTemplate<T>): Array<unknown>;
	render<T>(items: Iterable<T>, keyFn: KeyFn<T> | ItemTemplate<T>, template: ItemTemplate<T>): Array<unknown>;
	update<T>(containerPart: ChildPart, [items, keyFnOrTemplate, template]: [
		Iterable<T>,
		KeyFn<T> | ItemTemplate<T>,
		ItemTemplate<T>
	]): unknown[] | typeof noChange;
}
export interface RepeatDirectiveFn {
	<T>(items: Iterable<T>, keyFnOrTemplate: KeyFn<T> | ItemTemplate<T>, template?: ItemTemplate<T>): unknown;
	<T>(items: Iterable<T>, template: ItemTemplate<T>): unknown;
	<T>(items: Iterable<T>, keyFn: KeyFn<T> | ItemTemplate<T>, template: ItemTemplate<T>): unknown;
}
/**
 * A directive that repeats a series of values (usually `TemplateResults`)
 * generated from an iterable, and updates those items efficiently when the
 * iterable changes based on user-provided `keys` associated with each item.
 *
 * Note that if a `keyFn` is provided, strict key-to-DOM mapping is maintained,
 * meaning previous DOM for a given key is moved into the new position if
 * needed, and DOM will never be reused with values for different keys (new DOM
 * will always be created for new keys). This is generally the most efficient
 * way to use `repeat` since it performs minimum unnecessary work for insertions
 * and removals.
 *
 * The `keyFn` takes two parameters, the item and its index, and returns a unique key value.
 *
 * ```js
 * html`
 *   <ol>
 *     ${repeat(this.items, (item) => item.id, (item, index) => {
 *       return html`<li>${index}: ${item.name}</li>`;
 *     })}
 *   </ol>
 * `
 * ```
 *
 * **Important**: If providing a `keyFn`, keys *must* be unique for all items in a
 * given call to `repeat`. The behavior when two or more items have the same key
 * is undefined.
 *
 * If no `keyFn` is provided, this directive will perform similar to mapping
 * items to values, and DOM will be reused against potentially different items.
 */
export declare const repeat: RepeatDirectiveFn;
/**
 * A key-value set of CSS properties and values.
 *
 * The key should be either a valid CSS property name string, like
 * `'background-color'`, or a valid JavaScript camel case property name
 * for CSSStyleDeclaration like `backgroundColor`.
 */
export interface StyleInfo {
	[name: string]: string | number | undefined | null;
}
export declare class StyleMapDirective extends Directive {
	private _previousStyleProperties?;
	constructor(partInfo: PartInfo);
	render(styleInfo: Readonly<StyleInfo>): string;
	update(part: AttributePart, [styleInfo]: DirectiveParameters<this>): string | typeof noChange;
}
/**
 * A directive that applies CSS properties to an element.
 *
 * `styleMap` can only be used in the `style` attribute and must be the only
 * expression in the attribute. It takes the property names in the
 * {@link StyleInfo styleInfo} object and adds the properties to the inline
 * style of the element.
 *
 * Property names with dashes (`-`) are assumed to be valid CSS
 * property names and set on the element's style object using `setProperty()`.
 * Names without dashes are assumed to be camelCased JavaScript property names
 * and set on the element's style object using property assignment, allowing the
 * style object to translate JavaScript-style names to CSS property names.
 *
 * For example `styleMap({backgroundColor: 'red', 'border-top': '5px', '--size':
 * '0'})` sets the `background-color`, `border-top` and `--size` properties.
 *
 * @param styleInfo
 * @see {@link https://lit.dev/docs/templates/directives/#stylemap styleMap code samples on Lit.dev}
 */
export declare const styleMap: (styleInfo: Readonly<StyleInfo>) => DirectiveResult<typeof StyleMapDirective>;
export declare class TemplateContentDirective extends Directive {
	private _previousTemplate?;
	constructor(partInfo: PartInfo);
	render(template: HTMLTemplateElement): DocumentFragment | typeof noChange;
}
/**
 * Renders the content of a template element as HTML.
 *
 * Note, the template should be developer controlled and not user controlled.
 * Rendering a user-controlled template with this directive
 * could lead to cross-site-scripting vulnerabilities.
 */
export declare const templateContent: (template: HTMLTemplateElement) => DirectiveResult<typeof TemplateContentDirective>;
export declare class UntilDirective extends AsyncDirective {
	private __lastRenderedIndex;
	private __values;
	private __weakThis;
	private __pauser;
	render(...args: Array<unknown>): unknown;
	update(_part: Part, args: Array<unknown>): unknown;
	disconnected(): void;
	reconnected(): void;
}
/**
 * Renders one of a series of values, including Promises, to a Part.
 *
 * Values are rendered in priority order, with the first argument having the
 * highest priority and the last argument having the lowest priority. If a
 * value is a Promise, low-priority values will be rendered until it resolves.
 *
 * The priority of values can be used to create placeholder content for async
 * data. For example, a Promise with pending content can be the first,
 * highest-priority, argument, and a non_promise loading indicator template can
 * be used as the second, lower-priority, argument. The loading indicator will
 * render immediately, and the primary content will render when the Promise
 * resolves.
 *
 * Example:
 *
 * ```js
 * const content = fetch('./content.txt').then(r => r.text());
 * html`${until(content, html`<span>Loading...</span>`)}`
 * ```
 */
export declare const until: (...values: unknown[]) => DirectiveResult<typeof UntilDirective>;
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
export type Falsy = null | undefined | false | 0 | -0 | 0n | "";
/**
 * When `condition` is true, returns the result of calling `trueCase()`, else
 * returns the result of calling `falseCase()` if `falseCase` is defined.
 *
 * This is a convenience wrapper around a ternary expression that makes it a
 * little nicer to write an inline conditional without an else.
 *
 * @example
 *
 * ```ts
 * render() {
 *   return html`
 *     ${when(this.user, () => html`User: ${this.user.username}`, () => html`Sign In...`)}
 *   `;
 * }
 * ```
 */
export declare function when<C extends Falsy, T, F = undefined>(condition: C, trueCase: (c: C) => T, falseCase?: (c: C) => F): F;
export declare function when<C, T, F>(condition: C extends Falsy ? never : C, trueCase: (c: C) => T, falseCase?: (c: C) => F): T;
export declare function when<C, T, F = undefined>(condition: C, trueCase: (c: Exclude<C, Falsy>) => T, falseCase?: (c: Extract<C, Falsy>) => F): C extends Falsy ? F : T;
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * The Context type defines a type brand to associate a key value with the context value type
 */
export type Context<KeyType, ValueType> = KeyType & {
	__context__: ValueType;
};
/**
 * @deprecated use Context instead
 */
export type ContextKey<KeyType, ValueType> = Context<KeyType, ValueType>;
/**
 * A helper type which can extract a Context value type from a Context type
 */
export type ContextType<Key extends Context<unknown, unknown>> = Key extends Context<unknown, infer ValueType> ? ValueType : never;
/**
 * Creates a typed Context.
 *
 * Contexts are compared with strict equality.
 *
 * If you want two separate `createContext()` calls to referer to the same
 * context, then use a key that will by equal under strict equality like a
 * string for `Symbol.for()`:
 *
 * ```ts
 * // true
 * createContext('my-context') === createContext('my-context')
 * // true
 * createContext(Symbol.for('my-context')) === createContext(Symbol.for('my-context'))
 * ```
 *
 * If you want a context to be unique so that it's guaranteed to not collide
 * with other contexts, use a key that's unique under strict equality, like
 * a `Symbol()` or object.:
 *
 * ```
 * // false
 * createContext({}) === createContext({})
 * // false
 * createContext(Symbol('my-context')) === createContext(Symbol('my-context'))
 * ```
 *
 * @param key a context key value
 * @template ValueType the type of value that can be provided by this context.
 * @returns the context key value cast to `Context<K, ValueType>`
 */
export declare function createContext<ValueType, K = unknown>(key: K): Context<K, ValueType>;
/**
 * A callback which is provided by a context requester and is called with the value satisfying the request.
 * This callback can be called multiple times by context providers as the requested value is changed.
 */
export type ContextCallback<ValueType> = (value: ValueType, unsubscribe?: () => void) => void;
/**
 * Interface definition for a ContextRequest
 */
export interface ContextRequest<C extends Context<unknown, unknown>> {
	readonly context: C;
	readonly callback: ContextCallback<ContextType<C>>;
	readonly subscribe?: boolean;
}
/**
 * An event fired by a context requester to signal it desires a specified context with the given key.
 *
 * A provider should inspect the `context` property of the event to determine if it has a value that can
 * satisfy the request, calling the `callback` with the requested value if so.
 *
 * If the requested context event contains a truthy `subscribe` value, then a provider can call the callback
 * multiple times if the value is changed, if this is the case the provider should pass an `unsubscribe`
 * method to the callback which consumers can invoke to indicate they no longer wish to receive these updates.
 *
 * If no `subscribe` value is present in the event, then the provider can assume that this is a 'one time'
 * request for the context and can therefore not track the consumer.
 */
declare class ContextRequestEvent<C extends Context<unknown, unknown>> extends Event implements ContextRequest<C> {
	readonly context: C;
	readonly callback: ContextCallback<ContextType<C>>;
	readonly subscribe?: boolean;
	/**
	 *
	 * @param context the context key to request
	 * @param callback the callback that should be invoked when the context with the specified key is available
	 * @param subscribe when, true indicates we want to subscribe to future updates
	 */
	constructor(context: C, callback: ContextCallback<ContextType<C>>, subscribe?: boolean);
}
export interface Options<C extends Context<unknown, unknown>> {
	context: C;
	callback?: (value: ContextType<C>, dispose?: () => void) => void;
	subscribe?: boolean;
}
/**
 * A ReactiveController which adds context consuming behavior to a custom
 * element by dispatching `context-request` events.
 *
 * When the host element is connected to the document it will emit a
 * `context-request` event with its context key. When the context request
 * is satisfied the controller will invoke the callback, if present, and
 * trigger a host update so it can respond to the new value.
 *
 * It will also call the dispose method given by the provider when the
 * host element is disconnected.
 */
export declare class ContextConsumer<C extends Context<unknown, unknown>, HostElement extends ReactiveControllerHost & HTMLElement> implements ReactiveController {
	protected host: HostElement;
	private context;
	private callback?;
	private subscribe;
	private provided;
	value?: ContextType<C>;
	constructor(host: HostElement, options: Options<C>);
	/** @deprecated Use new ContextConsumer(host, options) */
	constructor(host: HostElement, context: C, callback?: (value: ContextType<C>, dispose?: () => void) => void, subscribe?: boolean);
	private unsubscribe?;
	hostConnected(): void;
	hostDisconnected(): void;
	private dispatchRequest;
	private _callback;
}
/**
 * A disposer function
 */
export type Disposer = () => void;
export interface CallbackInfo {
	disposer: Disposer;
	consumerHost: Element;
}
declare class ValueNotifier<T> {
	protected readonly subscriptions: Map<ContextCallback<T>, CallbackInfo>;
	private _value;
	get value(): T;
	set value(v: T);
	setValue(v: T, force?: boolean): void;
	constructor(defaultValue?: T);
	updateObservers: () => void;
	addCallback(callback: ContextCallback<T>, consumerHost: Element, subscribe?: boolean): void;
	clearCallbacks(): void;
}
declare class ContextProviderEvent<C extends Context<unknown, unknown>> extends Event {
	readonly context: C;
	/**
	 *
	 * @param context the context which this provider can provide
	 */
	constructor(context: C);
}
interface Options$1<C extends Context<unknown, unknown>> {
	context: C;
	initialValue?: ContextType<C>;
}
export type ReactiveElementHost = Partial<ReactiveControllerHost> & HTMLElement;
/**
 * A ReactiveController which adds context provider behavior to a
 * custom element.
 *
 * This controller simply listens to the `context-request` event when
 * the host is connected to the DOM and registers the received callbacks
 * against its observable Context implementation.
 *
 * The controller may also be attached to any HTML element in which case it's
 * up to the user to call hostConnected() when attached to the DOM. This is
 * done automatically for any custom elements implementing
 * ReactiveControllerHost.
 */
export declare class ContextProvider<T extends Context<unknown, unknown>, HostElement extends ReactiveElementHost = ReactiveElementHost> extends ValueNotifier<ContextType<T>> implements ReactiveController {
	protected readonly host: HostElement;
	private readonly context;
	constructor(host: HostElement, options: Options$1<T>);
	/** @deprecated Use new ContextProvider(host, options) */
	constructor(host: HostElement, context: T, initialValue?: ContextType<T>);
	onContextRequest: (ev: ContextRequestEvent<Context<unknown, unknown>>) => void;
	/**
	 * When we get a provider request event, that means a child of this element
	 * has just woken up. If it's a provider of our context, then we may need to
	 * re-parent our subscriptions, because is a more specific provider than us
	 * for its subtree.
	 */
	onProviderRequest: (ev: ContextProviderEvent<Context<unknown, unknown>>) => void;
	private attachListeners;
	hostConnected(): void;
}
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
/**
 * A ContextRoot can be used to gather unsatisfied context requests and
 * re-dispatch them when new providers which satisfy matching context keys are
 * available.
 *
 * This allows providers to be added to a DOM tree, or upgraded, after the
 * consumers.
 */
export declare class ContextRoot {
	private pendingContextRequests;
	/**
	 * Attach the ContextRoot to a given element to intercept `context-request` and
	 * `context-provider` events.
	 *
	 * @param element an element to add event listeners to
	 */
	attach(element: HTMLElement): void;
	/**
	 * Removes the ContextRoot event listeners from a given element.
	 *
	 * @param element an element from which to remove event listeners
	 */
	detach(element: HTMLElement): void;
	private onContextProvider;
	private onContextRequest;
}
/**
 * A property decorator that adds a ContextProvider controller to the component
 * making it respond to any `context-request` events from its children consumer.
 *
 * @param context A Context identifier value created via `createContext`
 *
 * @example
 *
 * ```ts
 * import {provide} from '@lit/context';
 * import {Logger} from 'my-logging-library';
 * import {loggerContext} from './logger-context.js';
 *
 * class MyElement {
 *   @provide({context: loggerContext})
 *   logger = new Logger();
 * }
 * ```
 * @category Decorator
 */
export declare function provide<ValueType>({ context: context, }: {
	context: Context<unknown, ValueType>;
}): ProvideDecorator<ValueType>;
/**
 * Generates a public interface type that removes private and protected fields.
 * This allows accepting otherwise compatible versions of the type (e.g. from
 * multiple copies of the same package in `node_modules`).
 */
export type Interface<T> = {
	[K in keyof T]: T[K];
};
export type ProvideDecorator<ContextType> = {
	<K extends PropertyKey, Proto extends Interface<Omit<ReactiveElement, "renderRoot">>>(protoOrDescriptor: Proto, name?: K): FieldMustMatchContextType<Proto, K, ContextType>;
	<C extends Interface<Omit<ReactiveElement, "renderRoot">>, V extends ContextType>(value: ClassAccessorDecoratorTarget<C, V>, context: ClassAccessorDecoratorContext<C, V>): void;
};
export type DecoratorReturn = void | any;
export type FieldMustMatchContextType<Obj, Key extends PropertyKey, ContextType> = Obj extends Record<Key, infer ProvidingType> ? [
	ProvidingType
] extends [
	ContextType
] ? DecoratorReturn : {
	message: "providing field not assignable to context";
	context: ContextType;
	provided: ProvidingType;
} : Obj extends Partial<Record<Key, infer Providing>> ? [
	Providing | undefined
] extends [
	ContextType
] ? DecoratorReturn : {
	message: "providing field not assignable to context";
	context: ContextType;
	consuming: Providing | undefined;
} : DecoratorReturn;
/**
 * A property decorator that adds a ContextConsumer controller to the component
 * which will try and retrieve a value for the property via the Context API.
 *
 * @param context A Context identifier value created via `createContext`
 * @param subscribe An optional boolean which when true allows the value to be updated
 *   multiple times.
 *
 * @example
 *
 * ```ts
 * import {consume} from '@lit/context';
 * import {loggerContext, Logger} from 'community-protocols/logger';
 *
 * class MyElement {
 *   @consume({context: loggerContext})
 *   logger?: Logger;
 *
 *   doThing() {
 *     this.logger!.log('thing was done');
 *   }
 * }
 * ```
 * @category Decorator
 */
export declare function consume<ValueType>({ context, subscribe, }: {
	context: Context<unknown, ValueType>;
	subscribe?: boolean;
}): ConsumeDecorator<ValueType>;
type Interface$1<T> = {
	[K in keyof T]: T[K];
};
export type ConsumeDecorator<ValueType> = {
	<K extends PropertyKey, Proto extends Interface$1<Omit<ReactiveElement, "renderRoot">>>(protoOrDescriptor: Proto, name?: K): FieldMustMatchProvidedType<Proto, K, ValueType>;
	<C extends Interface$1<Omit<ReactiveElement, "renderRoot">>, V extends ValueType>(value: ClassAccessorDecoratorTarget<C, V>, context: ClassAccessorDecoratorContext<C, V>): void;
};
type DecoratorReturn$1 = void | any;
export type FieldMustMatchProvidedType<Obj, Key extends PropertyKey, ProvidedType> = Obj extends Record<Key, infer ConsumingType> ? [
	ProvidedType
] extends [
	ConsumingType
] ? DecoratorReturn$1 : {
	message: "provided type not assignable to consuming field";
	provided: ProvidedType;
	consuming: ConsumingType;
} : Obj extends Partial<Record<Key, infer ConsumingType>> ? [
	ProvidedType
] extends [
	ConsumingType | undefined
] ? DecoratorReturn$1 : {
	message: "provided type not assignable to consuming field";
	provided: ProvidedType;
	consuming: ConsumingType | undefined;
} : DecoratorReturn$1;
export declare function LightDOM<T extends new (...args: any[]) => LitElement>(base: T): T;
declare class OnDismount extends AsyncDirective {
	render(): unknown;
	elem: Element | undefined;
	fn: ((elem: Element) => void) | undefined;
	update(_part: Part, [fn]: [
		(elem: Element) => void
	]): unknown;
	protected disconnected(): void;
}
export declare const onDismount: () => DirectiveResult<typeof OnDismount>;
declare class OnMount extends AsyncDirective {
	render(): unknown;
	update(_part: Part, [fn]: [
		(elem: Element) => void
	]): unknown;
}
export declare const onMount: () => DirectiveResult<typeof OnMount>;
export * from "@lit-labs/context";

export {
	ContextRequestEvent as ContextEvent,
};

export {};
