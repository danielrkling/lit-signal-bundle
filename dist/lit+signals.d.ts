// Generated by dts-bundle-generator v9.5.1

import { ReactiveElement, RenderOptions } from './lit';
import { AsyncDirective } from './lit';
import { DirectiveResult, Part } from './lit';
import { TemplateResult, html as coreHtml, svg as coreSvg } from './lit';
import { Signal } from './signals';

export declare class WatchDirective<T> extends AsyncDirective {
	private __host?;
	private __signal?;
	private __watcher?;
	private __computed?;
	private __watch;
	private __unwatch;
	commit(): void;
	render(signal: Signal.State<T> | Signal.Computed<T>): T;
	update(part: Part, [signal]: [
		signal: Signal.State<T> | Signal.Computed<T>
	]): T | undefined;
	protected disconnected(): void;
	protected reconnected(): void;
}
export type WatchDirectiveFunction = <T>(signal: Signal.State<T> | Signal.Computed<T>) => DirectiveResult<typeof WatchDirective<T>>;
/**
 * Renders a signal and subscribes to it, updating the part when the signal
 * changes.
 *
 * watch() can only be used in a reactive element that applies the
 * SignalWatcher mixin.
 */
export declare const watch: WatchDirectiveFunction;
export type ReactiveElementConstructor = abstract new (...args: any[]) => ReactiveElement;
export interface SignalWatcher extends ReactiveElement {
	_updateWatchDirective(d: WatchDirective<unknown>): void;
	_clearWatchDirective(d: WatchDirective<unknown>): void;
}
/**
 * Adds the ability for a LitElement or other ReactiveElement class to
 * watch for access to signals during the update lifecycle and trigger a new
 * update when signals values change.
 */
export declare function SignalWatcher<T extends ReactiveElementConstructor>(Base: T): T;
/**
 * Wraps a lit-html template tag function (`html` or `svg`) to add support for
 * automatically wrapping Signal instances in the `watch()` directive.
 */
export declare const withWatch: (coreTag: typeof coreHtml | typeof coreSvg) => (strings: TemplateStringsArray, ...values: unknown[]) => TemplateResult;
/**
 * Interprets a template literal as an HTML template that can efficiently
 * render to and update a container.
 *
 * Includes signal watching support from `withWatch()`.
 */
export declare const html: (strings: TemplateStringsArray, ...values: unknown[]) => TemplateResult;
/**
 * Interprets a template literal as an SVG template that can efficiently
 * render to and update a container.
 *
 * Includes signal watching support from `withWatch()`.
 */
export declare const svg: (strings: TemplateStringsArray, ...values: unknown[]) => TemplateResult;
export declare const State: typeof Signal.State;
export declare const Computed: typeof Signal.Computed;
export declare const signal: <T>(value: T, options?: Signal.Options<T>) => Signal.State<T>;
export declare const computed: <T>(callback: () => T, options?: Signal.Options<T>) => Signal.Computed<T>;
export declare class SignalHost {
	private isPendingUpdate;
	private __pendingWatches;
	_updateWatchDirective(d: WatchDirective<unknown>): void;
	_clearWatchDirective(d: WatchDirective<unknown>): void;
	requestUpdate(): void;
}
export declare function render(value: unknown, container: HTMLElement | DocumentFragment, options?: RenderOptions | undefined): import("lit-html").RootPart;
export * from "signal-polyfill";

export {
	Signal,
};

export {};
