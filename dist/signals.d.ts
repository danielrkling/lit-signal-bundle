// Generated by dts-bundle-generator v9.5.1

/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
export type Version = number & {
	__brand: "Version";
};
/**
 * A producer and/or consumer which participates in the reactive graph.
 *
 * Producer `ReactiveNode`s which are accessed when a consumer `ReactiveNode` is the
 * `activeConsumer` are tracked as dependencies of that consumer.
 *
 * Certain consumers are also tracked as "live" consumers and create edges in the other direction,
 * from producer to consumer. These edges are used to propagate change notifications when a
 * producer's value is updated.
 *
 * A `ReactiveNode` may be both a producer and consumer.
 */
export interface ReactiveNode {
	/**
	 * Version of the value that this node produces.
	 *
	 * This is incremented whenever a new value is produced by this node which is not equal to the
	 * previous value (by whatever definition of equality is in use).
	 */
	version: Version;
	/**
	 * Epoch at which this node is verified to be clean.
	 *
	 * This allows skipping of some polling operations in the case where no signals have been set
	 * since this node was last read.
	 */
	lastCleanEpoch: Version;
	/**
	 * Whether this node (in its consumer capacity) is dirty.
	 *
	 * Only live consumers become dirty, when receiving a change notification from a dependency
	 * producer.
	 */
	dirty: boolean;
	/**
	 * Producers which are dependencies of this consumer.
	 *
	 * Uses the same indices as the `producerLastReadVersion` and `producerIndexOfThis` arrays.
	 */
	producerNode: ReactiveNode[] | undefined;
	/**
	 * `Version` of the value last read by a given producer.
	 *
	 * Uses the same indices as the `producerNode` and `producerIndexOfThis` arrays.
	 */
	producerLastReadVersion: Version[] | undefined;
	/**
	 * Index of `this` (consumer) in each producer's `liveConsumers` array.
	 *
	 * This value is only meaningful if this node is live (`liveConsumers.length > 0`). Otherwise
	 * these indices are stale.
	 *
	 * Uses the same indices as the `producerNode` and `producerLastReadVersion` arrays.
	 */
	producerIndexOfThis: number[] | undefined;
	/**
	 * Index into the producer arrays that the next dependency of this node as a consumer will use.
	 *
	 * This index is zeroed before this node as a consumer begins executing. When a producer is read,
	 * it gets inserted into the producers arrays at this index. There may be an existing dependency
	 * in this location which may or may not match the incoming producer, depending on whether the
	 * same producers were read in the same order as the last computation.
	 */
	nextProducerIndex: number;
	/**
	 * Array of consumers of this producer that are "live" (they require push notifications).
	 *
	 * `liveConsumerNode.length` is effectively our reference count for this node.
	 */
	liveConsumerNode: ReactiveNode[] | undefined;
	/**
	 * Index of `this` (producer) in each consumer's `producerNode` array.
	 *
	 * Uses the same indices as the `liveConsumerNode` array.
	 */
	liveConsumerIndexOfThis: number[] | undefined;
	/**
	 * Whether writes to signals are allowed when this consumer is the `activeConsumer`.
	 *
	 * This is used to enforce guardrails such as preventing writes to writable signals in the
	 * computation function of computed signals, which is supposed to be pure.
	 */
	consumerAllowSignalWrites: boolean;
	readonly consumerIsAlwaysLive: boolean;
	/**
	 * Tracks whether producers need to recompute their value independently of the reactive graph (for
	 * example, if no initial value has been computed).
	 */
	producerMustRecompute(node: unknown): boolean;
	producerRecomputeValue(node: unknown): void;
	consumerMarkedDirty(this: unknown): void;
	/**
	 * Called when a signal is read within this consumer.
	 */
	consumerOnSignalRead(node: unknown): void;
	/**
	 * Called when the signal becomes "live"
	 */
	watched?(): void;
	/**
	 * Called when the signal stops being "live"
	 */
	unwatched?(): void;
	/**
	 * Optional extra data for embedder of this signal library.
	 * Sent to various callbacks as the this value.
	 */
	wrapper?: any;
}
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A comparison function which can determine if two values are equal.
 */
export type ValueEqualityFn<T> = (a: T, b: T) => boolean;
export interface SignalNode<T> extends ReactiveNode {
	value: T;
	equal: ValueEqualityFn<T>;
}
/**
 * A computation, which derives a value from a declarative reactive expression.
 *
 * `Computed`s are both producers and consumers of reactivity.
 */
export interface ComputedNode<T> extends ReactiveNode {
	/**
	 * Current value of the computation, or one of the sentinel values above (`UNSET`, `COMPUTING`,
	 * `ERROR`).
	 */
	value: T;
	/**
	 * If `value` is `ERRORED`, the error caught from the last computation attempt which will
	 * be re-thrown.
	 */
	error: unknown;
	/**
	 * The computation function which will produce a new value.
	 */
	computation: () => T;
	equal: ValueEqualityFn<T>;
}
declare const NODE: unique symbol;
export declare namespace Signal {
	export let isState: (s: any) => boolean, isComputed: (s: any) => boolean, isWatcher: (s: any) => boolean;
	export class State<T> {
		#private;
		readonly [NODE]: SignalNode<T>;
		constructor(initialValue: T, options?: Signal.Options<T>);
		get(): T;
		set(newValue: T): void;
	}
	export class Computed<T> {
		#private;
		readonly [NODE]: ComputedNode<T>;
		constructor(computation: () => T, options?: Signal.Options<T>);
		get(): T;
	}
	type AnySignal<T = any> = State<T> | Computed<T>;
	type AnySink = Computed<any> | subtle.Watcher;
	export namespace subtle {
		function untrack<T>(cb: () => T): T;
		function introspectSources(sink: AnySink): AnySignal[];
		function introspectSinks(signal: AnySignal): AnySink[];
		function hasSinks(signal: AnySignal): boolean;
		function hasSources(signal: AnySink): boolean;
		class Watcher {
			#private;
			readonly [NODE]: ReactiveNode;
			constructor(notify: (this: Watcher) => void);
			watch(...signals: AnySignal[]): void;
			unwatch(...signals: AnySignal[]): void;
			getPending(): Computed<any>[];
		}
		function currentComputed(): Computed<any> | undefined;
		const watched: unique symbol;
		const unwatched: unique symbol;
	}
	export interface Options<T> {
		equals?: (this: AnySignal<T>, t: T, t2: T) => boolean;
		[Signal.subtle.watched]?: (this: AnySignal<T>) => void;
		[Signal.subtle.unwatched]?: (this: AnySignal<T>) => void;
	}
	export {};
}
export interface SignalArray<T = unknown> extends Array<T> {
}
export declare class SignalArray<T = unknown> {
	#private;
	/**
	 * Creates an array from an iterable object.
	 * @param iterable An iterable object to convert to an array.
	 */
	static from<T>(iterable: Iterable<T> | ArrayLike<T>): SignalArray<T>;
	/**
	 * Creates an array from an iterable object.
	 * @param iterable An iterable object to convert to an array.
	 * @param mapfn A mapping function to call on every element of the array.
	 * @param thisArg Value of 'this' used to invoke the mapfn.
	 */
	static from<T, U>(iterable: Iterable<T> | ArrayLike<T>, mapfn: (v: T, k: number) => U, thisArg?: unknown): SignalArray<U>;
	static of<T>(...arr: T[]): SignalArray<T>;
	constructor(arr?: T[]);
}
export interface SignalObject {
	fromEntries<T = unknown>(entries: Iterable<readonly [
		PropertyKey,
		T
	]>): {
		[k: string]: T;
	};
	new <T extends Record<PropertyKey, unknown> = Record<PropertyKey, unknown>>(obj?: T): T;
}
/**
 * Create a reactive Object, backed by Signals, using a Proxy.
 * This allows dynamic creation and deletion of signals using the object primitive
 * APIs that most folks are familiar with -- the only difference is instantiation.
 * ```js
 * const obj = new SignalObject({ foo: 123 });
 *
 * obj.foo // 123
 * obj.foo = 456
 * obj.foo // 456
 * obj.bar = 2
 * obj.bar // 2
 * ```
 */
declare const SignalObject$1: SignalObject;
export declare class SignalMap<K = unknown, V = unknown> implements Map<K, V> {
	private collection;
	private storages;
	private vals;
	private readStorageFor;
	private dirtyStorageFor;
	constructor();
	constructor(entries: readonly (readonly [
		K,
		V
	])[] | null);
	constructor(iterable: Iterable<readonly [
		K,
		V
	]>);
	get(key: K): V | undefined;
	has(key: K): boolean;
	entries(): IterableIterator<[
		K,
		V
	]>;
	keys(): IterableIterator<K>;
	values(): IterableIterator<V>;
	forEach(fn: (value: V, key: K, map: Map<K, V>) => void): void;
	get size(): number;
	[Symbol.iterator](): IterableIterator<[
		K,
		V
	]>;
	get [Symbol.toStringTag](): string;
	set(key: K, value: V): this;
	delete(key: K): boolean;
	clear(): void;
}
export declare class SignalSet<T = unknown> implements Set<T> {
	private collection;
	private storages;
	private vals;
	private storageFor;
	private dirtyStorageFor;
	constructor();
	constructor(values: readonly T[] | null);
	constructor(iterable: Iterable<T>);
	has(value: T): boolean;
	entries(): IterableIterator<[
		T,
		T
	]>;
	keys(): IterableIterator<T>;
	values(): IterableIterator<T>;
	forEach(fn: (value1: T, value2: T, set: Set<T>) => void): void;
	get size(): number;
	[Symbol.iterator](): IterableIterator<T>;
	get [Symbol.toStringTag](): string;
	add(value: T): this;
	delete(value: T): boolean;
	clear(): void;
}
/**
 * ⚠️ WARNING: Nothing unwatches ⚠️
 * This will produce a memory leak.
 */
export declare function effect(cb: () => void): () => void;
export type AsyncMemoFetch<T> = () => Promise<T>;
export type AsyncMemoOptions<T> = {
	initialValue: T;
	staleTime: number;
};
export type AsyncMemoStatus = "initial" | "stale" | "resolved" | "rejected" | "fetching";
export declare function asyncMemo<T>(fn: () => Promise<T>, options: AsyncMemoOptions<T>): AsyncMemo<T>;
export declare class AsyncMemo<T> {
	#private;
	staleTime: number | undefined;
	constructor(fn: () => Promise<T>, options?: AsyncMemoOptions<T>);
	refresh(): Promise<void>;
	get value(): T | undefined;
	setValue(value: T): void;
	get error(): unknown;
	get status(): AsyncMemoStatus;
	get isPending(): boolean;
	get isResolved(): boolean;
	get isRejected(): boolean;
}
export declare function query<T>(key: string, fn: AsyncMemoFetch<T>, options: AsyncMemoOptions<T>): AsyncMemo<T>;
export type ValidationError = Error | string | null | undefined;
export type Validate<TValue> = (value: TValue) => Promise<ValidationError> | ValidationError;
export type ControlOptions<TValue> = {
	validate?: Validate<TValue>;
	initialValue?: TValue;
	fields?: {
		[K in keyof TValue]: Omit<ControlOptions<TValue[K]>, "initialValue">;
	};
};
export type Fields<TValue> = {
	[K in keyof TValue]: Control<TValue[K]>;
};
declare abstract class Control<TValue> {
	#private;
	initialValue: TValue | undefined;
	fields: Fields<TValue>;
	constructor(options?: ControlOptions<TValue>);
	get fieldArray(): Field<TValue>[];
	validate(): Promise<boolean>;
	get error(): ValidationError;
	get isValidated(): boolean;
	get isValidating(): boolean;
	get errors(): ValidationError[];
	get isPristine(): boolean;
	get isDirty(): boolean;
	get isInvalid(): Boolean;
	get isValid(): false;
	get value(): TValue;
	setValue(value: TValue): void;
}
export type FormOptions<TValue extends object> = ControlOptions<TValue> & {};
export declare class Form<TValue extends object = {}> extends Control<TValue> {
	#private;
	constructor(options: FormOptions<TValue>);
	get value(): TValue;
	setValue(value: TValue): void;
	handleSubmit(onValid?: (value: TValue, control: Form<TValue>) => unknown, onInvalid?: (value: TValue, control: Form<TValue>) => unknown): Promise<void>;
	get submitCount(): number;
	get isSubmitted(): boolean;
	get isSubmitting(): boolean;
	focusError(): boolean;
}
declare class Field<TParent, TKey extends keyof TParent = keyof TParent, TValue = TParent[TKey]> extends Control<TValue> {
	#private;
	control: Control<TParent>;
	name: TKey;
	ref: {
		value?: HTMLElement;
	};
	constructor(control: Control<TParent>, name: TKey, options?: ControlOptions<TValue>);
	get value(): TValue;
	setValue(value: TValue): void;
	focusError(): boolean;
}
export declare function signal<T>(initialValue: T, options?: Signal.Options<T>): Signal.State<T>;
export declare function memo<T>(computation: () => T, options?: Signal.Options<T>): Signal.Computed<T>;
export declare function writableMemo<T>(computation: () => T, options?: Signal.Options<T>): Signal.State<T>;

export {
	SignalObject$1 as SignalObject,
};

export {};
